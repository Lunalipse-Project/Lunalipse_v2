//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from LpsScriptParser.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Lunalipse.Core.BehaviorScript.ScriptV3.SyntaxParser {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class LpsScriptParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		PROG_NAME_DECLARE=1, CATALOGUE_CHOOSE=2, PLAY=3, PLAY_NUM=4, SET_EQULAIZER=5, 
		DO_BUILDIN_FUNC=6, PROGRAM_GROUP_START=7, PROGRAM_GROUP_END=8, DO_ACTIONS=9, 
		INDEXING_PREFIX=10, INDEXING_INDEX=11, ASSIGN_PREFIX=12, MAKE_CONSTANT=13, 
		ASSIGN_TO=14, PARAMETER_SPLIT=15, TRUE=16, FALSE=17, DO=18, IF=19, IF_SUFX=20, 
		ELSE=21, END_IF=22, BREAK=23, BREAK_LOOP=24, LOOP=25, END_LOOP=26, END_PROGRAM=27, 
		AUTHUR_NAME=28, DECLR=29, FULLSTOP=30, COLON=31, WITH_ACTION=32, VOLUM=33, 
		REPEAT_TIMES=34, LSQUARE=35, RSQUARE=36, LPAREN=37, RPAREN=38, COMMA=39, 
		ADD=40, MINUS=41, MULT=42, DIV=43, AND=44, OR=45, NOT=46, GR=47, LS=48, 
		GE=49, LE=50, EQ=51, NEQ=52, INT=53, REAL=54, ID=55, COMMENT_SINGLE=56, 
		COMMENT_MULTI=57, WS=58, NEW_LINE=59, DONT_CARE1=60, END=61, DONT_CARE2=62, 
		STRING=63, Wspace=64, PROG_START=65, RQUOTE=66;
	public const int
		RULE_prg = 0, RULE_prg_start = 1, RULE_prg_end = 2, RULE_prg_content = 3, 
		RULE_statements = 4, RULE_statements_loop = 5, RULE_if_branch = 6, RULE_else_branch = 7, 
		RULE_if_branch_loop = 8, RULE_else_branch_loop = 9, RULE_loop = 10, RULE_declares = 11, 
		RULE_declare = 12, RULE_declare_ids = 13, RULE_statement = 14, RULE_statement_loop = 15, 
		RULE_cata_choose = 16, RULE_play_actions = 17, RULE_set_eqzr = 18, RULE_do_action = 19, 
		RULE_group_statemnt = 20, RULE_loop_act = 21, RULE_volume_set = 22, RULE_conditions = 23, 
		RULE_condition = 24, RULE_assign = 25, RULE_expr_wrap = 26, RULE_expr = 27, 
		RULE_func_call = 28, RULE_array_indexing = 29, RULE_array = 30, RULE_array_content = 31, 
		RULE_any = 32, RULE_any_id = 33, RULE_any_number = 34, RULE_bool = 35, 
		RULE_optr_P0 = 36, RULE_optr_P1 = 37, RULE_optr_P2 = 38, RULE_optr_P3 = 39, 
		RULE_optr_P4 = 40, RULE_optr_P5 = 41, RULE_optr_P6 = 42;
	public static readonly string[] ruleNames = {
		"prg", "prg_start", "prg_end", "prg_content", "statements", "statements_loop", 
		"if_branch", "else_branch", "if_branch_loop", "else_branch_loop", "loop", 
		"declares", "declare", "declare_ids", "statement", "statement_loop", "cata_choose", 
		"play_actions", "set_eqzr", "do_action", "group_statemnt", "loop_act", 
		"volume_set", "conditions", "condition", "assign", "expr_wrap", "expr", 
		"func_call", "array_indexing", "array", "array_content", "any", "any_id", 
		"any_number", "bool", "optr_P0", "optr_P1", "optr_P2", "optr_P3", "optr_P4", 
		"optr_P5", "optr_P6"
	};

	private static readonly string[] _LiteralNames = {
		null, "'I would like to tell you my adventure of '", "'For the stuff in '", 
		"'I play music called '", "'I play music numbered '", "'And I would like to set my equalizer using '", 
		null, "'I made up an checklist with the following items'", "'and that is all about checklist of '", 
		"'I start checking the checklist called '", "'I ask '", "' for the stuff at position of '", 
		"'I told '", "'that I have made a Pinkie promise'", "' about '", "' with constraints'", 
		"'true'", "'false'", "'I do the following'", "'when '", "' becomes true'", 
		"'otherwise it should be'", "'that is the decision I made'", "'I want to stop here'", 
		"'I want to leave the loop'", "'I started a loop'", "'that is my loop'", 
		"'And that is my adventure in today'", "'Your loyal citizen:'", "'I have '", 
		"'.'", "':'", "'for '", "' percent of awesomeness'", "' times'", "'['", 
		"']'", "'('", "')'", "','", "'+'", "'-'", "'*'", "'/'", "'and'", "'or'", 
		"'not'", "'greater than'", "'less than'", "'greater than or equals to'", 
		"'less than or equals to'", "'equals to'", "'not equals to'", null, null, 
		null, "'P.S.'", "'Here my long waffle start:'", null, null, null, "'And my long waffle end.'", 
		null, null, null, "'Dear Princess Luna:'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "PROG_NAME_DECLARE", "CATALOGUE_CHOOSE", "PLAY", "PLAY_NUM", "SET_EQULAIZER", 
		"DO_BUILDIN_FUNC", "PROGRAM_GROUP_START", "PROGRAM_GROUP_END", "DO_ACTIONS", 
		"INDEXING_PREFIX", "INDEXING_INDEX", "ASSIGN_PREFIX", "MAKE_CONSTANT", 
		"ASSIGN_TO", "PARAMETER_SPLIT", "TRUE", "FALSE", "DO", "IF", "IF_SUFX", 
		"ELSE", "END_IF", "BREAK", "BREAK_LOOP", "LOOP", "END_LOOP", "END_PROGRAM", 
		"AUTHUR_NAME", "DECLR", "FULLSTOP", "COLON", "WITH_ACTION", "VOLUM", "REPEAT_TIMES", 
		"LSQUARE", "RSQUARE", "LPAREN", "RPAREN", "COMMA", "ADD", "MINUS", "MULT", 
		"DIV", "AND", "OR", "NOT", "GR", "LS", "GE", "LE", "EQ", "NEQ", "INT", 
		"REAL", "ID", "COMMENT_SINGLE", "COMMENT_MULTI", "WS", "NEW_LINE", "DONT_CARE1", 
		"END", "DONT_CARE2", "STRING", "Wspace", "PROG_START", "RQUOTE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "LpsScriptParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static LpsScriptParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public LpsScriptParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public LpsScriptParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class PrgContext : ParserRuleContext {
		public Prg_startContext prg_start() {
			return GetRuleContext<Prg_startContext>(0);
		}
		public Prg_contentContext prg_content() {
			return GetRuleContext<Prg_contentContext>(0);
		}
		public Prg_endContext prg_end() {
			return GetRuleContext<Prg_endContext>(0);
		}
		public PrgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrgContext prg() {
		PrgContext _localctx = new PrgContext(Context, State);
		EnterRule(_localctx, 0, RULE_prg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 86; prg_start();
			State = 87; prg_content();
			State = 88; prg_end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prg_startContext : ParserRuleContext {
		public ITerminalNode PROG_START() { return GetToken(LpsScriptParser.PROG_START, 0); }
		public ITerminalNode PROG_NAME_DECLARE() { return GetToken(LpsScriptParser.PROG_NAME_DECLARE, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public Prg_startContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg_start; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg_start(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prg_startContext prg_start() {
		Prg_startContext _localctx = new Prg_startContext(Context, State);
		EnterRule(_localctx, 2, RULE_prg_start);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90; Match(PROG_START);
			State = 91; Match(PROG_NAME_DECLARE);
			State = 92; Match(ID);
			State = 93; Match(FULLSTOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prg_endContext : ParserRuleContext {
		public ITerminalNode END_PROGRAM() { return GetToken(LpsScriptParser.END_PROGRAM, 0); }
		public ITerminalNode[] FULLSTOP() { return GetTokens(LpsScriptParser.FULLSTOP); }
		public ITerminalNode FULLSTOP(int i) {
			return GetToken(LpsScriptParser.FULLSTOP, i);
		}
		public ITerminalNode AUTHUR_NAME() { return GetToken(LpsScriptParser.AUTHUR_NAME, 0); }
		public ITerminalNode STRING() { return GetToken(LpsScriptParser.STRING, 0); }
		public Prg_endContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg_end; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg_end(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prg_endContext prg_end() {
		Prg_endContext _localctx = new Prg_endContext(Context, State);
		EnterRule(_localctx, 4, RULE_prg_end);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 95; Match(END_PROGRAM);
			State = 96; Match(FULLSTOP);
			State = 97; Match(AUTHUR_NAME);
			State = 98; Match(STRING);
			State = 99; Match(FULLSTOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prg_contentContext : ParserRuleContext {
		public DeclaresContext declares() {
			return GetRuleContext<DeclaresContext>(0);
		}
		public Group_statemntContext group_statemnt() {
			return GetRuleContext<Group_statemntContext>(0);
		}
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public Prg_contentContext prg_content() {
			return GetRuleContext<Prg_contentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public Prg_contentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg_content; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg_content(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prg_contentContext prg_content() {
		Prg_contentContext _localctx = new Prg_contentContext(Context, State);
		EnterRule(_localctx, 6, RULE_prg_content);
		try {
			State = 110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 101; declares(0);
				State = 102; group_statemnt();
				State = 103; Match(FULLSTOP);
				State = 104; prg_content();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 106; declares(0);
				State = 107; statements(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		return statements(0);
	}

	private StatementsContext statements(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StatementsContext _localctx = new StatementsContext(Context, _parentState);
		StatementsContext _prevctx = _localctx;
		int _startState = 8;
		EnterRecursionRule(_localctx, 8, RULE_statements, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			}
			Context.Stop = TokenStream.LT(-1);
			State = 117;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StatementsContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_statements);
					State = 113;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 114; statement();
					}
					} 
				}
				State = 119;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Statements_loopContext : ParserRuleContext {
		public Statements_loopContext statements_loop() {
			return GetRuleContext<Statements_loopContext>(0);
		}
		public Statement_loopContext statement_loop() {
			return GetRuleContext<Statement_loopContext>(0);
		}
		public Statements_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Statements_loopContext statements_loop() {
		return statements_loop(0);
	}

	private Statements_loopContext statements_loop(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Statements_loopContext _localctx = new Statements_loopContext(Context, _parentState);
		Statements_loopContext _prevctx = _localctx;
		int _startState = 10;
		EnterRecursionRule(_localctx, 10, RULE_statements_loop, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			}
			Context.Stop = TokenStream.LT(-1);
			State = 125;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Statements_loopContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_statements_loop);
					State = 121;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 122; statement_loop();
					}
					} 
				}
				State = 127;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class If_branchContext : ParserRuleContext {
		public ITerminalNode DO() { return GetToken(LpsScriptParser.DO, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode IF() { return GetToken(LpsScriptParser.IF, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode IF_SUFX() { return GetToken(LpsScriptParser.IF_SUFX, 0); }
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public ITerminalNode END_IF() { return GetToken(LpsScriptParser.END_IF, 0); }
		public Else_branchContext else_branch() {
			return GetRuleContext<Else_branchContext>(0);
		}
		public If_branchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_branch; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_branch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_branchContext if_branch() {
		If_branchContext _localctx = new If_branchContext(Context, State);
		EnterRule(_localctx, 12, RULE_if_branch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128; Match(DO);
			State = 129; Match(COLON);
			State = 130; statements(0);
			State = 131; Match(IF);
			State = 132; expr_wrap();
			State = 133; Match(IF_SUFX);
			State = 134; Match(COMMA);
			State = 136;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 135; else_branch();
				}
			}

			State = 138; Match(END_IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Else_branchContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(LpsScriptParser.ELSE, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public Else_branchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else_branch; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElse_branch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Else_branchContext else_branch() {
		Else_branchContext _localctx = new Else_branchContext(Context, State);
		EnterRule(_localctx, 14, RULE_else_branch);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 140; Match(ELSE);
			State = 141; Match(COLON);
			State = 142; statements(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_branch_loopContext : ParserRuleContext {
		public ITerminalNode DO() { return GetToken(LpsScriptParser.DO, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public Statements_loopContext statements_loop() {
			return GetRuleContext<Statements_loopContext>(0);
		}
		public ITerminalNode IF() { return GetToken(LpsScriptParser.IF, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode IF_SUFX() { return GetToken(LpsScriptParser.IF_SUFX, 0); }
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public ITerminalNode END_IF() { return GetToken(LpsScriptParser.END_IF, 0); }
		public Else_branch_loopContext else_branch_loop() {
			return GetRuleContext<Else_branch_loopContext>(0);
		}
		public If_branch_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_branch_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_branch_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_branch_loopContext if_branch_loop() {
		If_branch_loopContext _localctx = new If_branch_loopContext(Context, State);
		EnterRule(_localctx, 16, RULE_if_branch_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144; Match(DO);
			State = 145; Match(COLON);
			State = 146; statements_loop(0);
			State = 147; Match(IF);
			State = 148; expr_wrap();
			State = 149; Match(IF_SUFX);
			State = 150; Match(COMMA);
			State = 152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 151; else_branch_loop();
				}
			}

			State = 154; Match(END_IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Else_branch_loopContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(LpsScriptParser.ELSE, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public Statements_loopContext statements_loop() {
			return GetRuleContext<Statements_loopContext>(0);
		}
		public Else_branch_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else_branch_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElse_branch_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Else_branch_loopContext else_branch_loop() {
		Else_branch_loopContext _localctx = new Else_branch_loopContext(Context, State);
		EnterRule(_localctx, 18, RULE_else_branch_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 156; Match(ELSE);
			State = 157; Match(COLON);
			State = 158; statements_loop(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopContext : ParserRuleContext {
		public ITerminalNode LOOP() { return GetToken(LpsScriptParser.LOOP, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public Statements_loopContext statements_loop() {
			return GetRuleContext<Statements_loopContext>(0);
		}
		public ITerminalNode END_LOOP() { return GetToken(LpsScriptParser.END_LOOP, 0); }
		public LoopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopContext loop() {
		LoopContext _localctx = new LoopContext(Context, State);
		EnterRule(_localctx, 20, RULE_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 160; Match(LOOP);
			State = 161; Match(COLON);
			State = 162; statements_loop(0);
			State = 163; Match(END_LOOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclaresContext : ParserRuleContext {
		public DeclareContext declare() {
			return GetRuleContext<DeclareContext>(0);
		}
		public DeclaresContext declares() {
			return GetRuleContext<DeclaresContext>(0);
		}
		public DeclaresContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declares; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclares(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclaresContext declares() {
		return declares(0);
	}

	private DeclaresContext declares(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DeclaresContext _localctx = new DeclaresContext(Context, _parentState);
		DeclaresContext _prevctx = _localctx;
		int _startState = 22;
		EnterRecursionRule(_localctx, 22, RULE_declares, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				{
				State = 166; declare();
				}
				break;
			case 2:
				{
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 174;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new DeclaresContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_declares);
					State = 170;
					if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
					State = 171; declare();
					}
					} 
				}
				State = 176;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclareContext : ParserRuleContext {
		public ITerminalNode DECLR() { return GetToken(LpsScriptParser.DECLR, 0); }
		public Declare_idsContext declare_ids() {
			return GetRuleContext<Declare_idsContext>(0);
		}
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public DeclareContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclareContext declare() {
		DeclareContext _localctx = new DeclareContext(Context, State);
		EnterRule(_localctx, 24, RULE_declare);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 177; Match(DECLR);
			State = 178; declare_ids(0);
			State = 179; Match(FULLSTOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_idsContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Declare_idsContext[] declare_ids() {
			return GetRuleContexts<Declare_idsContext>();
		}
		public Declare_idsContext declare_ids(int i) {
			return GetRuleContext<Declare_idsContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public Declare_idsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_ids; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare_ids(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declare_idsContext declare_ids() {
		return declare_ids(0);
	}

	private Declare_idsContext declare_ids(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Declare_idsContext _localctx = new Declare_idsContext(Context, _parentState);
		Declare_idsContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_declare_ids, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 182; Match(ID);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 189;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Declare_idsContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_declare_ids);
					State = 184;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 185; Match(COMMA);
					State = 186; declare_ids(2);
					}
					} 
				}
				State = 191;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public Cata_chooseContext cata_choose() {
			return GetRuleContext<Cata_chooseContext>(0);
		}
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public Play_actionsContext play_actions() {
			return GetRuleContext<Play_actionsContext>(0);
		}
		public ConditionsContext conditions() {
			return GetRuleContext<ConditionsContext>(0);
		}
		public Set_eqzrContext set_eqzr() {
			return GetRuleContext<Set_eqzrContext>(0);
		}
		public Do_actionContext do_action() {
			return GetRuleContext<Do_actionContext>(0);
		}
		public AssignContext assign() {
			return GetRuleContext<AssignContext>(0);
		}
		public Func_callContext func_call() {
			return GetRuleContext<Func_callContext>(0);
		}
		public LoopContext loop() {
			return GetRuleContext<LoopContext>(0);
		}
		public If_branchContext if_branch() {
			return GetRuleContext<If_branchContext>(0);
		}
		public ITerminalNode BREAK() { return GetToken(LpsScriptParser.BREAK, 0); }
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 28, RULE_statement);
		int _la;
		try {
			State = 227;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CATALOGUE_CHOOSE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 192; cata_choose();
				State = 193; Match(FULLSTOP);
				}
				break;
			case PLAY:
			case PLAY_NUM:
				EnterOuterAlt(_localctx, 2);
				{
				State = 195; play_actions();
				State = 197;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH_ACTION) {
					{
					State = 196; conditions(0);
					}
				}

				State = 199; Match(FULLSTOP);
				}
				break;
			case SET_EQULAIZER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 201; set_eqzr();
				State = 202; Match(FULLSTOP);
				}
				break;
			case DO_ACTIONS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 204; do_action();
				State = 206;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH_ACTION) {
					{
					State = 205; conditions(0);
					}
				}

				State = 208; Match(FULLSTOP);
				}
				break;
			case ASSIGN_PREFIX:
				EnterOuterAlt(_localctx, 5);
				{
				State = 210; assign();
				State = 211; Match(FULLSTOP);
				}
				break;
			case DO_BUILDIN_FUNC:
				EnterOuterAlt(_localctx, 6);
				{
				State = 213; func_call();
				State = 215;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH_ACTION) {
					{
					State = 214; conditions(0);
					}
				}

				State = 217; Match(FULLSTOP);
				}
				break;
			case LOOP:
				EnterOuterAlt(_localctx, 7);
				{
				State = 219; loop();
				State = 220; Match(FULLSTOP);
				}
				break;
			case DO:
				EnterOuterAlt(_localctx, 8);
				{
				State = 222; if_branch();
				State = 223; Match(FULLSTOP);
				}
				break;
			case BREAK:
				EnterOuterAlt(_localctx, 9);
				{
				State = 225; Match(BREAK);
				State = 226; Match(FULLSTOP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Statement_loopContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode BREAK_LOOP() { return GetToken(LpsScriptParser.BREAK_LOOP, 0); }
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public If_branch_loopContext if_branch_loop() {
			return GetRuleContext<If_branch_loopContext>(0);
		}
		public Statement_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Statement_loopContext statement_loop() {
		Statement_loopContext _localctx = new Statement_loopContext(Context, State);
		EnterRule(_localctx, 30, RULE_statement_loop);
		try {
			State = 235;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 229; statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 230; Match(BREAK_LOOP);
				State = 231; Match(FULLSTOP);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 232; if_branch_loop();
				State = 233; Match(FULLSTOP);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cata_chooseContext : ParserRuleContext {
		public ITerminalNode CATALOGUE_CHOOSE() { return GetToken(LpsScriptParser.CATALOGUE_CHOOSE, 0); }
		public Any_idContext any_id() {
			return GetRuleContext<Any_idContext>(0);
		}
		public Cata_chooseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cata_choose; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCata_choose(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cata_chooseContext cata_choose() {
		Cata_chooseContext _localctx = new Cata_chooseContext(Context, State);
		EnterRule(_localctx, 32, RULE_cata_choose);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 237; Match(CATALOGUE_CHOOSE);
			State = 238; any_id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Play_actionsContext : ParserRuleContext {
		public ITerminalNode PLAY() { return GetToken(LpsScriptParser.PLAY, 0); }
		public ITerminalNode STRING() { return GetToken(LpsScriptParser.STRING, 0); }
		public ITerminalNode PLAY_NUM() { return GetToken(LpsScriptParser.PLAY_NUM, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public Play_actionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_play_actions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlay_actions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Play_actionsContext play_actions() {
		Play_actionsContext _localctx = new Play_actionsContext(Context, State);
		EnterRule(_localctx, 34, RULE_play_actions);
		try {
			State = 244;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLAY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 240; Match(PLAY);
				State = 241; Match(STRING);
				}
				break;
			case PLAY_NUM:
				EnterOuterAlt(_localctx, 2);
				{
				State = 242; Match(PLAY_NUM);
				State = 243; expr_wrap();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_eqzrContext : ParserRuleContext {
		public ITerminalNode SET_EQULAIZER() { return GetToken(LpsScriptParser.SET_EQULAIZER, 0); }
		public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Set_eqzrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_eqzr; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_eqzr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_eqzrContext set_eqzr() {
		Set_eqzrContext _localctx = new Set_eqzrContext(Context, State);
		EnterRule(_localctx, 36, RULE_set_eqzr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 246; Match(SET_EQULAIZER);
			State = 249;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LSQUARE:
				{
				State = 247; array();
				}
				break;
			case ID:
				{
				State = 248; Match(ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Do_actionContext : ParserRuleContext {
		public ITerminalNode DO_ACTIONS() { return GetToken(LpsScriptParser.DO_ACTIONS, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Do_actionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_do_action; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDo_action(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Do_actionContext do_action() {
		Do_actionContext _localctx = new Do_actionContext(Context, State);
		EnterRule(_localctx, 38, RULE_do_action);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 251; Match(DO_ACTIONS);
			State = 252; Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_statemntContext : ParserRuleContext {
		public ITerminalNode PROGRAM_GROUP_START() { return GetToken(LpsScriptParser.PROGRAM_GROUP_START, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode PROGRAM_GROUP_END() { return GetToken(LpsScriptParser.PROGRAM_GROUP_END, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Group_statemntContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_statemnt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_statemnt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_statemntContext group_statemnt() {
		Group_statemntContext _localctx = new Group_statemntContext(Context, State);
		EnterRule(_localctx, 40, RULE_group_statemnt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 254; Match(PROGRAM_GROUP_START);
			State = 255; Match(COLON);
			State = 256; statements(0);
			State = 257; Match(PROGRAM_GROUP_END);
			State = 258; Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_actContext : ParserRuleContext {
		public Loop_actContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_act; } }
	 
		public Loop_actContext() { }
		public virtual void CopyFrom(Loop_actContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SuffixLoopContext : Loop_actContext {
		public ITerminalNode WITH_ACTION() { return GetToken(LpsScriptParser.WITH_ACTION, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode REPEAT_TIMES() { return GetToken(LpsScriptParser.REPEAT_TIMES, 0); }
		public SuffixLoopContext(Loop_actContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSuffixLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_actContext loop_act() {
		Loop_actContext _localctx = new Loop_actContext(Context, State);
		EnterRule(_localctx, 42, RULE_loop_act);
		try {
			_localctx = new SuffixLoopContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 260; Match(WITH_ACTION);
			State = 261; expr_wrap();
			State = 262; Match(REPEAT_TIMES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Volume_setContext : ParserRuleContext {
		public Volume_setContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_volume_set; } }
	 
		public Volume_setContext() { }
		public virtual void CopyFrom(Volume_setContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SuffixSetVolContext : Volume_setContext {
		public ITerminalNode WITH_ACTION() { return GetToken(LpsScriptParser.WITH_ACTION, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode VOLUM() { return GetToken(LpsScriptParser.VOLUM, 0); }
		public SuffixSetVolContext(Volume_setContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSuffixSetVol(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Volume_setContext volume_set() {
		Volume_setContext _localctx = new Volume_setContext(Context, State);
		EnterRule(_localctx, 44, RULE_volume_set);
		try {
			_localctx = new SuffixSetVolContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 264; Match(WITH_ACTION);
			State = 265; expr_wrap();
			State = 266; Match(VOLUM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionsContext : ParserRuleContext {
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ConditionsContext[] conditions() {
			return GetRuleContexts<ConditionsContext>();
		}
		public ConditionsContext conditions(int i) {
			return GetRuleContext<ConditionsContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public ConditionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionsContext conditions() {
		return conditions(0);
	}

	private ConditionsContext conditions(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ConditionsContext _localctx = new ConditionsContext(Context, _parentState);
		ConditionsContext _prevctx = _localctx;
		int _startState = 46;
		EnterRecursionRule(_localctx, 46, RULE_conditions, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 269; condition();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 276;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ConditionsContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_conditions);
					State = 271;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 272; Match(COMMA);
					State = 273; conditions(2);
					}
					} 
				}
				State = 278;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public Loop_actContext loop_act() {
			return GetRuleContext<Loop_actContext>(0);
		}
		public Volume_setContext volume_set() {
			return GetRuleContext<Volume_setContext>(0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(Context, State);
		EnterRule(_localctx, 48, RULE_condition);
		try {
			State = 281;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 279; loop_act();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 280; volume_set();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignContext : ParserRuleContext {
		public ITerminalNode ASSIGN_PREFIX() { return GetToken(LpsScriptParser.ASSIGN_PREFIX, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode ASSIGN_TO() { return GetToken(LpsScriptParser.ASSIGN_TO, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode MAKE_CONSTANT() { return GetToken(LpsScriptParser.MAKE_CONSTANT, 0); }
		public AssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assign; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignContext assign() {
		AssignContext _localctx = new AssignContext(Context, State);
		EnterRule(_localctx, 50, RULE_assign);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 283; Match(ASSIGN_PREFIX);
			State = 284; Match(ID);
			State = 286;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MAKE_CONSTANT) {
				{
				State = 285; Match(MAKE_CONSTANT);
				}
			}

			State = 288; Match(ASSIGN_TO);
			State = 289; expr_wrap();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expr_wrapContext : ParserRuleContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public Expr_wrapContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr_wrap; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_wrap(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expr_wrapContext expr_wrap() {
		Expr_wrapContext _localctx = new Expr_wrapContext(Context, State);
		EnterRule(_localctx, 52, RULE_expr_wrap);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 291; expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
	 
		public ExprContext() { }
		public virtual void CopyFrom(ExprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExprIndContext : ExprContext {
		public Func_callContext func_call() {
			return GetRuleContext<Func_callContext>(0);
		}
		public Array_indexingContext array_indexing() {
			return GetRuleContext<Array_indexingContext>(0);
		}
		public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public BoolContext @bool() {
			return GetRuleContext<BoolContext>(0);
		}
		public AnyContext any() {
			return GetRuleContext<AnyContext>(0);
		}
		public ExprIndContext(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprInd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP4Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P4Context optr_P4() {
			return GetRuleContext<Optr_P4Context>(0);
		}
		public ExprP4Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP4(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprParenContext : ExprContext {
		public ITerminalNode LPAREN() { return GetToken(LpsScriptParser.LPAREN, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(LpsScriptParser.RPAREN, 0); }
		public ExprParenContext(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprParen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP3Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P3Context optr_P3() {
			return GetRuleContext<Optr_P3Context>(0);
		}
		public ExprP3Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP3(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP6Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P6Context optr_P6() {
			return GetRuleContext<Optr_P6Context>(0);
		}
		public ExprP6Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP6(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP5Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P5Context optr_P5() {
			return GetRuleContext<Optr_P5Context>(0);
		}
		public ExprP5Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP5(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprUnaryContext : ExprContext {
		public Optr_P0Context optr_P0() {
			return GetRuleContext<Optr_P0Context>(0);
		}
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ExprUnaryContext(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP2Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P2Context optr_P2() {
			return GetRuleContext<Optr_P2Context>(0);
		}
		public ExprP2Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP1Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P1Context optr_P1() {
			return GetRuleContext<Optr_P1Context>(0);
		}
		public ExprP1Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		return expr(0);
	}

	private ExprContext expr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExprContext _localctx = new ExprContext(Context, _parentState);
		ExprContext _prevctx = _localctx;
		int _startState = 54;
		EnterRecursionRule(_localctx, 54, RULE_expr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 306;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
			case MINUS:
			case NOT:
				{
				_localctx = new ExprUnaryContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 294; optr_P0();
				State = 295; expr(13);
				}
				break;
			case DO_BUILDIN_FUNC:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 297; func_call();
				}
				break;
			case INDEXING_PREFIX:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 298; array_indexing();
				}
				break;
			case LSQUARE:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 299; array();
				}
				break;
			case TRUE:
			case FALSE:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 300; @bool();
				}
				break;
			case INT:
			case REAL:
			case ID:
			case STRING:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 301; any();
				}
				break;
			case LPAREN:
				{
				_localctx = new ExprParenContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 302; Match(LPAREN);
				State = 303; expr(0);
				State = 304; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 334;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 332;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,19,Context) ) {
					case 1:
						{
						_localctx = new ExprP1Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 308;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 309; optr_P1();
						State = 310; expr(13);
						}
						break;
					case 2:
						{
						_localctx = new ExprP2Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 312;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 313; optr_P2();
						State = 314; expr(12);
						}
						break;
					case 3:
						{
						_localctx = new ExprP3Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 316;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 317; optr_P3();
						State = 318; expr(11);
						}
						break;
					case 4:
						{
						_localctx = new ExprP4Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 320;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 321; optr_P4();
						State = 322; expr(10);
						}
						break;
					case 5:
						{
						_localctx = new ExprP5Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 324;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 325; optr_P5();
						State = 326; expr(9);
						}
						break;
					case 6:
						{
						_localctx = new ExprP6Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 328;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 329; optr_P6();
						State = 330; expr(8);
						}
						break;
					}
					} 
				}
				State = 336;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Func_callContext : ParserRuleContext {
		public ITerminalNode DO_BUILDIN_FUNC() { return GetToken(LpsScriptParser.DO_BUILDIN_FUNC, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode PARAMETER_SPLIT() { return GetToken(LpsScriptParser.PARAMETER_SPLIT, 0); }
		public ITerminalNode COLON() { return GetToken(LpsScriptParser.COLON, 0); }
		public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public Func_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func_call; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Func_callContext func_call() {
		Func_callContext _localctx = new Func_callContext(Context, State);
		EnterRule(_localctx, 56, RULE_func_call);
		try {
			State = 344;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 337; Match(DO_BUILDIN_FUNC);
				State = 338; Match(ID);
				State = 339; Match(PARAMETER_SPLIT);
				State = 340; Match(COLON);
				State = 341; array();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 342; Match(DO_BUILDIN_FUNC);
				State = 343; Match(ID);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_indexingContext : ParserRuleContext {
		public ITerminalNode INDEXING_PREFIX() { return GetToken(LpsScriptParser.INDEXING_PREFIX, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode INDEXING_INDEX() { return GetToken(LpsScriptParser.INDEXING_INDEX, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public Array_indexingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_indexing; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_indexing(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_indexingContext array_indexing() {
		Array_indexingContext _localctx = new Array_indexingContext(Context, State);
		EnterRule(_localctx, 58, RULE_array_indexing);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 346; Match(INDEXING_PREFIX);
			State = 347; Match(ID);
			State = 348; Match(INDEXING_INDEX);
			State = 349; expr_wrap();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayContext : ParserRuleContext {
		public ArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array; } }
	 
		public ArrayContext() { }
		public virtual void CopyFrom(ArrayContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ArrayDeclrContext : ArrayContext {
		public ITerminalNode LSQUARE() { return GetToken(LpsScriptParser.LSQUARE, 0); }
		public Array_contentContext array_content() {
			return GetRuleContext<Array_contentContext>(0);
		}
		public ITerminalNode RSQUARE() { return GetToken(LpsScriptParser.RSQUARE, 0); }
		public ArrayDeclrContext(ArrayContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayDeclr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayContext array() {
		ArrayContext _localctx = new ArrayContext(Context, State);
		EnterRule(_localctx, 60, RULE_array);
		try {
			_localctx = new ArrayDeclrContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 351; Match(LSQUARE);
			State = 352; array_content(0);
			State = 353; Match(RSQUARE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_contentContext : ParserRuleContext {
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public Array_contentContext[] array_content() {
			return GetRuleContexts<Array_contentContext>();
		}
		public Array_contentContext array_content(int i) {
			return GetRuleContext<Array_contentContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public Array_contentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_content; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_content(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_contentContext array_content() {
		return array_content(0);
	}

	private Array_contentContext array_content(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Array_contentContext _localctx = new Array_contentContext(Context, _parentState);
		Array_contentContext _prevctx = _localctx;
		int _startState = 62;
		EnterRecursionRule(_localctx, 62, RULE_array_content, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 358;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				{
				State = 356; expr_wrap();
				}
				break;
			case 2:
				{
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 365;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Array_contentContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_array_content);
					State = 360;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 361; Match(COMMA);
					State = 362; array_content(3);
					}
					} 
				}
				State = 367;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AnyContext : ParserRuleContext {
		public Any_idContext any_id() {
			return GetRuleContext<Any_idContext>(0);
		}
		public Any_numberContext any_number() {
			return GetRuleContext<Any_numberContext>(0);
		}
		public AnyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_any; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAny(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnyContext any() {
		AnyContext _localctx = new AnyContext(Context, State);
		EnterRule(_localctx, 64, RULE_any);
		try {
			State = 370;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ID:
			case STRING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 368; any_id();
				}
				break;
			case INT:
			case REAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 369; any_number();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Any_idContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode STRING() { return GetToken(LpsScriptParser.STRING, 0); }
		public Any_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_any_id; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAny_id(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Any_idContext any_id() {
		Any_idContext _localctx = new Any_idContext(Context, State);
		EnterRule(_localctx, 66, RULE_any_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 372;
			_la = TokenStream.LA(1);
			if ( !(_la==ID || _la==STRING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Any_numberContext : ParserRuleContext {
		public ITerminalNode REAL() { return GetToken(LpsScriptParser.REAL, 0); }
		public ITerminalNode INT() { return GetToken(LpsScriptParser.INT, 0); }
		public Any_numberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_any_number; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAny_number(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Any_numberContext any_number() {
		Any_numberContext _localctx = new Any_numberContext(Context, State);
		EnterRule(_localctx, 68, RULE_any_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 374;
			_la = TokenStream.LA(1);
			if ( !(_la==INT || _la==REAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolContext : ParserRuleContext {
		public ITerminalNode TRUE() { return GetToken(LpsScriptParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(LpsScriptParser.FALSE, 0); }
		public BoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolContext @bool() {
		BoolContext _localctx = new BoolContext(Context, State);
		EnterRule(_localctx, 70, RULE_bool);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 376;
			_la = TokenStream.LA(1);
			if ( !(_la==TRUE || _la==FALSE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P0Context : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(LpsScriptParser.NOT, 0); }
		public ITerminalNode ADD() { return GetToken(LpsScriptParser.ADD, 0); }
		public ITerminalNode MINUS() { return GetToken(LpsScriptParser.MINUS, 0); }
		public Optr_P0Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P0; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P0(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P0Context optr_P0() {
		Optr_P0Context _localctx = new Optr_P0Context(Context, State);
		EnterRule(_localctx, 72, RULE_optr_P0);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 378;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ADD) | (1L << MINUS) | (1L << NOT))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P1Context : ParserRuleContext {
		public ITerminalNode MULT() { return GetToken(LpsScriptParser.MULT, 0); }
		public ITerminalNode DIV() { return GetToken(LpsScriptParser.DIV, 0); }
		public Optr_P1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P1; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P1Context optr_P1() {
		Optr_P1Context _localctx = new Optr_P1Context(Context, State);
		EnterRule(_localctx, 74, RULE_optr_P1);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 380;
			_la = TokenStream.LA(1);
			if ( !(_la==MULT || _la==DIV) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P2Context : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(LpsScriptParser.ADD, 0); }
		public ITerminalNode MINUS() { return GetToken(LpsScriptParser.MINUS, 0); }
		public Optr_P2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P2; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P2Context optr_P2() {
		Optr_P2Context _localctx = new Optr_P2Context(Context, State);
		EnterRule(_localctx, 76, RULE_optr_P2);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 382;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==MINUS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P3Context : ParserRuleContext {
		public ITerminalNode GR() { return GetToken(LpsScriptParser.GR, 0); }
		public ITerminalNode LS() { return GetToken(LpsScriptParser.LS, 0); }
		public ITerminalNode GE() { return GetToken(LpsScriptParser.GE, 0); }
		public ITerminalNode LE() { return GetToken(LpsScriptParser.LE, 0); }
		public Optr_P3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P3; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P3(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P3Context optr_P3() {
		Optr_P3Context _localctx = new Optr_P3Context(Context, State);
		EnterRule(_localctx, 78, RULE_optr_P3);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 384;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GR) | (1L << LS) | (1L << GE) | (1L << LE))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P4Context : ParserRuleContext {
		public ITerminalNode EQ() { return GetToken(LpsScriptParser.EQ, 0); }
		public ITerminalNode NEQ() { return GetToken(LpsScriptParser.NEQ, 0); }
		public Optr_P4Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P4; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P4(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P4Context optr_P4() {
		Optr_P4Context _localctx = new Optr_P4Context(Context, State);
		EnterRule(_localctx, 80, RULE_optr_P4);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 386;
			_la = TokenStream.LA(1);
			if ( !(_la==EQ || _la==NEQ) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P5Context : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(LpsScriptParser.AND, 0); }
		public Optr_P5Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P5; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P5(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P5Context optr_P5() {
		Optr_P5Context _localctx = new Optr_P5Context(Context, State);
		EnterRule(_localctx, 82, RULE_optr_P5);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 388; Match(AND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P6Context : ParserRuleContext {
		public ITerminalNode OR() { return GetToken(LpsScriptParser.OR, 0); }
		public Optr_P6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P6; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P6(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P6Context optr_P6() {
		Optr_P6Context _localctx = new Optr_P6Context(Context, State);
		EnterRule(_localctx, 84, RULE_optr_P6);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 390; Match(OR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 4: return statements_sempred((StatementsContext)_localctx, predIndex);
		case 5: return statements_loop_sempred((Statements_loopContext)_localctx, predIndex);
		case 11: return declares_sempred((DeclaresContext)_localctx, predIndex);
		case 13: return declare_ids_sempred((Declare_idsContext)_localctx, predIndex);
		case 23: return conditions_sempred((ConditionsContext)_localctx, predIndex);
		case 27: return expr_sempred((ExprContext)_localctx, predIndex);
		case 31: return array_content_sempred((Array_contentContext)_localctx, predIndex);
		}
		return true;
	}
	private bool statements_sempred(StatementsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		}
		return true;
	}
	private bool statements_loop_sempred(Statements_loopContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 2);
		}
		return true;
	}
	private bool declares_sempred(DeclaresContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 3);
		}
		return true;
	}
	private bool declare_ids_sempred(Declare_idsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 3: return Precpred(Context, 1);
		}
		return true;
	}
	private bool conditions_sempred(ConditionsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 1);
		}
		return true;
	}
	private bool expr_sempred(ExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(Context, 12);
		case 6: return Precpred(Context, 11);
		case 7: return Precpred(Context, 10);
		case 8: return Precpred(Context, 9);
		case 9: return Precpred(Context, 8);
		case 10: return Precpred(Context, 7);
		}
		return true;
	}
	private bool array_content_sempred(Array_contentContext _localctx, int predIndex) {
		switch (predIndex) {
		case 11: return Precpred(Context, 2);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x44', '\x18B', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', 
		'\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x5', '\x5', 
		'q', '\n', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\a', '\x6', 
		'v', '\n', '\x6', '\f', '\x6', '\xE', '\x6', 'y', '\v', '\x6', '\x3', 
		'\a', '\x3', '\a', '\x3', '\a', '\a', '\a', '~', '\n', '\a', '\f', '\a', 
		'\xE', '\a', '\x81', '\v', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\b', 
		'\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x5', 
		'\b', '\x8B', '\n', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\t', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\n', '\x3', '\n', '\x3', '\n', 
		'\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x5', 
		'\n', '\x9B', '\n', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', 
		'\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3', '\f', 
		'\x3', '\f', '\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x5', 
		'\r', '\xAB', '\n', '\r', '\x3', '\r', '\x3', '\r', '\a', '\r', '\xAF', 
		'\n', '\r', '\f', '\r', '\xE', '\r', '\xB2', '\v', '\r', '\x3', '\xE', 
		'\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xF', '\x3', '\xF', 
		'\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\a', '\xF', '\xBE', 
		'\n', '\xF', '\f', '\xF', '\xE', '\xF', '\xC1', '\v', '\xF', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x5', '\x10', 
		'\xC8', '\n', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x5', '\x10', '\xD1', 
		'\n', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x5', '\x10', '\xDA', '\n', 
		'\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x10', '\x5', '\x10', '\xE6', '\n', '\x10', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x5', '\x11', 
		'\xEE', '\n', '\x11', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x5', '\x13', '\xF7', 
		'\n', '\x13', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x5', '\x14', 
		'\xFC', '\n', '\x14', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', 
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', 
		'\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x19', '\x3', 
		'\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\a', 
		'\x19', '\x115', '\n', '\x19', '\f', '\x19', '\xE', '\x19', '\x118', '\v', 
		'\x19', '\x3', '\x1A', '\x3', '\x1A', '\x5', '\x1A', '\x11C', '\n', '\x1A', 
		'\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x121', '\n', 
		'\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1C', '\x3', 
		'\x1C', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x5', '\x1D', '\x135', 
		'\n', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', 
		'\a', '\x1D', '\x14F', '\n', '\x1D', '\f', '\x1D', '\xE', '\x1D', '\x152', 
		'\v', '\x1D', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', 
		'\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x5', '\x1E', '\x15B', '\n', 
		'\x1E', '\x3', '\x1F', '\x3', '\x1F', '\x3', '\x1F', '\x3', '\x1F', '\x3', 
		'\x1F', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\x3', '!', '\x3', 
		'!', '\x3', '!', '\x5', '!', '\x169', '\n', '!', '\x3', '!', '\x3', '!', 
		'\x3', '!', '\a', '!', '\x16E', '\n', '!', '\f', '!', '\xE', '!', '\x171', 
		'\v', '!', '\x3', '\"', '\x3', '\"', '\x5', '\"', '\x175', '\n', '\"', 
		'\x3', '#', '\x3', '#', '\x3', '$', '\x3', '$', '\x3', '%', '\x3', '%', 
		'\x3', '&', '\x3', '&', '\x3', '\'', '\x3', '\'', '\x3', '(', '\x3', '(', 
		'\x3', ')', '\x3', ')', '\x3', '*', '\x3', '*', '\x3', '+', '\x3', '+', 
		'\x3', ',', '\x3', ',', '\x3', ',', '\x2', '\t', '\n', '\f', '\x18', '\x1C', 
		'\x30', '\x38', '@', '-', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', 
		'\x10', '\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', 
		'$', '&', '(', '*', ',', '.', '\x30', '\x32', '\x34', '\x36', '\x38', 
		':', '<', '>', '@', '\x42', '\x44', '\x46', 'H', 'J', 'L', 'N', 'P', 'R', 
		'T', 'V', '\x2', '\n', '\x4', '\x2', '\x39', '\x39', '\x41', '\x41', '\x3', 
		'\x2', '\x37', '\x38', '\x3', '\x2', '\x12', '\x13', '\x4', '\x2', '*', 
		'+', '\x30', '\x30', '\x3', '\x2', ',', '-', '\x3', '\x2', '*', '+', '\x3', 
		'\x2', '\x31', '\x34', '\x3', '\x2', '\x35', '\x36', '\x2', '\x18A', '\x2', 
		'X', '\x3', '\x2', '\x2', '\x2', '\x4', '\\', '\x3', '\x2', '\x2', '\x2', 
		'\x6', '\x61', '\x3', '\x2', '\x2', '\x2', '\b', 'p', '\x3', '\x2', '\x2', 
		'\x2', '\n', 'r', '\x3', '\x2', '\x2', '\x2', '\f', 'z', '\x3', '\x2', 
		'\x2', '\x2', '\xE', '\x82', '\x3', '\x2', '\x2', '\x2', '\x10', '\x8E', 
		'\x3', '\x2', '\x2', '\x2', '\x12', '\x92', '\x3', '\x2', '\x2', '\x2', 
		'\x14', '\x9E', '\x3', '\x2', '\x2', '\x2', '\x16', '\xA2', '\x3', '\x2', 
		'\x2', '\x2', '\x18', '\xAA', '\x3', '\x2', '\x2', '\x2', '\x1A', '\xB3', 
		'\x3', '\x2', '\x2', '\x2', '\x1C', '\xB7', '\x3', '\x2', '\x2', '\x2', 
		'\x1E', '\xE5', '\x3', '\x2', '\x2', '\x2', ' ', '\xED', '\x3', '\x2', 
		'\x2', '\x2', '\"', '\xEF', '\x3', '\x2', '\x2', '\x2', '$', '\xF6', '\x3', 
		'\x2', '\x2', '\x2', '&', '\xF8', '\x3', '\x2', '\x2', '\x2', '(', '\xFD', 
		'\x3', '\x2', '\x2', '\x2', '*', '\x100', '\x3', '\x2', '\x2', '\x2', 
		',', '\x106', '\x3', '\x2', '\x2', '\x2', '.', '\x10A', '\x3', '\x2', 
		'\x2', '\x2', '\x30', '\x10E', '\x3', '\x2', '\x2', '\x2', '\x32', '\x11B', 
		'\x3', '\x2', '\x2', '\x2', '\x34', '\x11D', '\x3', '\x2', '\x2', '\x2', 
		'\x36', '\x125', '\x3', '\x2', '\x2', '\x2', '\x38', '\x134', '\x3', '\x2', 
		'\x2', '\x2', ':', '\x15A', '\x3', '\x2', '\x2', '\x2', '<', '\x15C', 
		'\x3', '\x2', '\x2', '\x2', '>', '\x161', '\x3', '\x2', '\x2', '\x2', 
		'@', '\x168', '\x3', '\x2', '\x2', '\x2', '\x42', '\x174', '\x3', '\x2', 
		'\x2', '\x2', '\x44', '\x176', '\x3', '\x2', '\x2', '\x2', '\x46', '\x178', 
		'\x3', '\x2', '\x2', '\x2', 'H', '\x17A', '\x3', '\x2', '\x2', '\x2', 
		'J', '\x17C', '\x3', '\x2', '\x2', '\x2', 'L', '\x17E', '\x3', '\x2', 
		'\x2', '\x2', 'N', '\x180', '\x3', '\x2', '\x2', '\x2', 'P', '\x182', 
		'\x3', '\x2', '\x2', '\x2', 'R', '\x184', '\x3', '\x2', '\x2', '\x2', 
		'T', '\x186', '\x3', '\x2', '\x2', '\x2', 'V', '\x188', '\x3', '\x2', 
		'\x2', '\x2', 'X', 'Y', '\x5', '\x4', '\x3', '\x2', 'Y', 'Z', '\x5', '\b', 
		'\x5', '\x2', 'Z', '[', '\x5', '\x6', '\x4', '\x2', '[', '\x3', '\x3', 
		'\x2', '\x2', '\x2', '\\', ']', '\a', '\x43', '\x2', '\x2', ']', '^', 
		'\a', '\x3', '\x2', '\x2', '^', '_', '\a', '\x39', '\x2', '\x2', '_', 
		'`', '\a', ' ', '\x2', '\x2', '`', '\x5', '\x3', '\x2', '\x2', '\x2', 
		'\x61', '\x62', '\a', '\x1D', '\x2', '\x2', '\x62', '\x63', '\a', ' ', 
		'\x2', '\x2', '\x63', '\x64', '\a', '\x1E', '\x2', '\x2', '\x64', '\x65', 
		'\a', '\x41', '\x2', '\x2', '\x65', '\x66', '\a', ' ', '\x2', '\x2', '\x66', 
		'\a', '\x3', '\x2', '\x2', '\x2', 'g', 'h', '\x5', '\x18', '\r', '\x2', 
		'h', 'i', '\x5', '*', '\x16', '\x2', 'i', 'j', '\a', ' ', '\x2', '\x2', 
		'j', 'k', '\x5', '\b', '\x5', '\x2', 'k', 'q', '\x3', '\x2', '\x2', '\x2', 
		'l', 'm', '\x5', '\x18', '\r', '\x2', 'm', 'n', '\x5', '\n', '\x6', '\x2', 
		'n', 'q', '\x3', '\x2', '\x2', '\x2', 'o', 'q', '\x3', '\x2', '\x2', '\x2', 
		'p', 'g', '\x3', '\x2', '\x2', '\x2', 'p', 'l', '\x3', '\x2', '\x2', '\x2', 
		'p', 'o', '\x3', '\x2', '\x2', '\x2', 'q', '\t', '\x3', '\x2', '\x2', 
		'\x2', 'r', 'w', '\b', '\x6', '\x1', '\x2', 's', 't', '\f', '\x4', '\x2', 
		'\x2', 't', 'v', '\x5', '\x1E', '\x10', '\x2', 'u', 's', '\x3', '\x2', 
		'\x2', '\x2', 'v', 'y', '\x3', '\x2', '\x2', '\x2', 'w', 'u', '\x3', '\x2', 
		'\x2', '\x2', 'w', 'x', '\x3', '\x2', '\x2', '\x2', 'x', '\v', '\x3', 
		'\x2', '\x2', '\x2', 'y', 'w', '\x3', '\x2', '\x2', '\x2', 'z', '\x7F', 
		'\b', '\a', '\x1', '\x2', '{', '|', '\f', '\x4', '\x2', '\x2', '|', '~', 
		'\x5', ' ', '\x11', '\x2', '}', '{', '\x3', '\x2', '\x2', '\x2', '~', 
		'\x81', '\x3', '\x2', '\x2', '\x2', '\x7F', '}', '\x3', '\x2', '\x2', 
		'\x2', '\x7F', '\x80', '\x3', '\x2', '\x2', '\x2', '\x80', '\r', '\x3', 
		'\x2', '\x2', '\x2', '\x81', '\x7F', '\x3', '\x2', '\x2', '\x2', '\x82', 
		'\x83', '\a', '\x14', '\x2', '\x2', '\x83', '\x84', '\a', '!', '\x2', 
		'\x2', '\x84', '\x85', '\x5', '\n', '\x6', '\x2', '\x85', '\x86', '\a', 
		'\x15', '\x2', '\x2', '\x86', '\x87', '\x5', '\x36', '\x1C', '\x2', '\x87', 
		'\x88', '\a', '\x16', '\x2', '\x2', '\x88', '\x8A', '\a', ')', '\x2', 
		'\x2', '\x89', '\x8B', '\x5', '\x10', '\t', '\x2', '\x8A', '\x89', '\x3', 
		'\x2', '\x2', '\x2', '\x8A', '\x8B', '\x3', '\x2', '\x2', '\x2', '\x8B', 
		'\x8C', '\x3', '\x2', '\x2', '\x2', '\x8C', '\x8D', '\a', '\x18', '\x2', 
		'\x2', '\x8D', '\xF', '\x3', '\x2', '\x2', '\x2', '\x8E', '\x8F', '\a', 
		'\x17', '\x2', '\x2', '\x8F', '\x90', '\a', '!', '\x2', '\x2', '\x90', 
		'\x91', '\x5', '\n', '\x6', '\x2', '\x91', '\x11', '\x3', '\x2', '\x2', 
		'\x2', '\x92', '\x93', '\a', '\x14', '\x2', '\x2', '\x93', '\x94', '\a', 
		'!', '\x2', '\x2', '\x94', '\x95', '\x5', '\f', '\a', '\x2', '\x95', '\x96', 
		'\a', '\x15', '\x2', '\x2', '\x96', '\x97', '\x5', '\x36', '\x1C', '\x2', 
		'\x97', '\x98', '\a', '\x16', '\x2', '\x2', '\x98', '\x9A', '\a', ')', 
		'\x2', '\x2', '\x99', '\x9B', '\x5', '\x14', '\v', '\x2', '\x9A', '\x99', 
		'\x3', '\x2', '\x2', '\x2', '\x9A', '\x9B', '\x3', '\x2', '\x2', '\x2', 
		'\x9B', '\x9C', '\x3', '\x2', '\x2', '\x2', '\x9C', '\x9D', '\a', '\x18', 
		'\x2', '\x2', '\x9D', '\x13', '\x3', '\x2', '\x2', '\x2', '\x9E', '\x9F', 
		'\a', '\x17', '\x2', '\x2', '\x9F', '\xA0', '\a', '!', '\x2', '\x2', '\xA0', 
		'\xA1', '\x5', '\f', '\a', '\x2', '\xA1', '\x15', '\x3', '\x2', '\x2', 
		'\x2', '\xA2', '\xA3', '\a', '\x1B', '\x2', '\x2', '\xA3', '\xA4', '\a', 
		'!', '\x2', '\x2', '\xA4', '\xA5', '\x5', '\f', '\a', '\x2', '\xA5', '\xA6', 
		'\a', '\x1C', '\x2', '\x2', '\xA6', '\x17', '\x3', '\x2', '\x2', '\x2', 
		'\xA7', '\xA8', '\b', '\r', '\x1', '\x2', '\xA8', '\xAB', '\x5', '\x1A', 
		'\xE', '\x2', '\xA9', '\xAB', '\x3', '\x2', '\x2', '\x2', '\xAA', '\xA7', 
		'\x3', '\x2', '\x2', '\x2', '\xAA', '\xA9', '\x3', '\x2', '\x2', '\x2', 
		'\xAB', '\xB0', '\x3', '\x2', '\x2', '\x2', '\xAC', '\xAD', '\f', '\x5', 
		'\x2', '\x2', '\xAD', '\xAF', '\x5', '\x1A', '\xE', '\x2', '\xAE', '\xAC', 
		'\x3', '\x2', '\x2', '\x2', '\xAF', '\xB2', '\x3', '\x2', '\x2', '\x2', 
		'\xB0', '\xAE', '\x3', '\x2', '\x2', '\x2', '\xB0', '\xB1', '\x3', '\x2', 
		'\x2', '\x2', '\xB1', '\x19', '\x3', '\x2', '\x2', '\x2', '\xB2', '\xB0', 
		'\x3', '\x2', '\x2', '\x2', '\xB3', '\xB4', '\a', '\x1F', '\x2', '\x2', 
		'\xB4', '\xB5', '\x5', '\x1C', '\xF', '\x2', '\xB5', '\xB6', '\a', ' ', 
		'\x2', '\x2', '\xB6', '\x1B', '\x3', '\x2', '\x2', '\x2', '\xB7', '\xB8', 
		'\b', '\xF', '\x1', '\x2', '\xB8', '\xB9', '\a', '\x39', '\x2', '\x2', 
		'\xB9', '\xBF', '\x3', '\x2', '\x2', '\x2', '\xBA', '\xBB', '\f', '\x3', 
		'\x2', '\x2', '\xBB', '\xBC', '\a', ')', '\x2', '\x2', '\xBC', '\xBE', 
		'\x5', '\x1C', '\xF', '\x4', '\xBD', '\xBA', '\x3', '\x2', '\x2', '\x2', 
		'\xBE', '\xC1', '\x3', '\x2', '\x2', '\x2', '\xBF', '\xBD', '\x3', '\x2', 
		'\x2', '\x2', '\xBF', '\xC0', '\x3', '\x2', '\x2', '\x2', '\xC0', '\x1D', 
		'\x3', '\x2', '\x2', '\x2', '\xC1', '\xBF', '\x3', '\x2', '\x2', '\x2', 
		'\xC2', '\xC3', '\x5', '\"', '\x12', '\x2', '\xC3', '\xC4', '\a', ' ', 
		'\x2', '\x2', '\xC4', '\xE6', '\x3', '\x2', '\x2', '\x2', '\xC5', '\xC7', 
		'\x5', '$', '\x13', '\x2', '\xC6', '\xC8', '\x5', '\x30', '\x19', '\x2', 
		'\xC7', '\xC6', '\x3', '\x2', '\x2', '\x2', '\xC7', '\xC8', '\x3', '\x2', 
		'\x2', '\x2', '\xC8', '\xC9', '\x3', '\x2', '\x2', '\x2', '\xC9', '\xCA', 
		'\a', ' ', '\x2', '\x2', '\xCA', '\xE6', '\x3', '\x2', '\x2', '\x2', '\xCB', 
		'\xCC', '\x5', '&', '\x14', '\x2', '\xCC', '\xCD', '\a', ' ', '\x2', '\x2', 
		'\xCD', '\xE6', '\x3', '\x2', '\x2', '\x2', '\xCE', '\xD0', '\x5', '(', 
		'\x15', '\x2', '\xCF', '\xD1', '\x5', '\x30', '\x19', '\x2', '\xD0', '\xCF', 
		'\x3', '\x2', '\x2', '\x2', '\xD0', '\xD1', '\x3', '\x2', '\x2', '\x2', 
		'\xD1', '\xD2', '\x3', '\x2', '\x2', '\x2', '\xD2', '\xD3', '\a', ' ', 
		'\x2', '\x2', '\xD3', '\xE6', '\x3', '\x2', '\x2', '\x2', '\xD4', '\xD5', 
		'\x5', '\x34', '\x1B', '\x2', '\xD5', '\xD6', '\a', ' ', '\x2', '\x2', 
		'\xD6', '\xE6', '\x3', '\x2', '\x2', '\x2', '\xD7', '\xD9', '\x5', ':', 
		'\x1E', '\x2', '\xD8', '\xDA', '\x5', '\x30', '\x19', '\x2', '\xD9', '\xD8', 
		'\x3', '\x2', '\x2', '\x2', '\xD9', '\xDA', '\x3', '\x2', '\x2', '\x2', 
		'\xDA', '\xDB', '\x3', '\x2', '\x2', '\x2', '\xDB', '\xDC', '\a', ' ', 
		'\x2', '\x2', '\xDC', '\xE6', '\x3', '\x2', '\x2', '\x2', '\xDD', '\xDE', 
		'\x5', '\x16', '\f', '\x2', '\xDE', '\xDF', '\a', ' ', '\x2', '\x2', '\xDF', 
		'\xE6', '\x3', '\x2', '\x2', '\x2', '\xE0', '\xE1', '\x5', '\xE', '\b', 
		'\x2', '\xE1', '\xE2', '\a', ' ', '\x2', '\x2', '\xE2', '\xE6', '\x3', 
		'\x2', '\x2', '\x2', '\xE3', '\xE4', '\a', '\x19', '\x2', '\x2', '\xE4', 
		'\xE6', '\a', ' ', '\x2', '\x2', '\xE5', '\xC2', '\x3', '\x2', '\x2', 
		'\x2', '\xE5', '\xC5', '\x3', '\x2', '\x2', '\x2', '\xE5', '\xCB', '\x3', 
		'\x2', '\x2', '\x2', '\xE5', '\xCE', '\x3', '\x2', '\x2', '\x2', '\xE5', 
		'\xD4', '\x3', '\x2', '\x2', '\x2', '\xE5', '\xD7', '\x3', '\x2', '\x2', 
		'\x2', '\xE5', '\xDD', '\x3', '\x2', '\x2', '\x2', '\xE5', '\xE0', '\x3', 
		'\x2', '\x2', '\x2', '\xE5', '\xE3', '\x3', '\x2', '\x2', '\x2', '\xE6', 
		'\x1F', '\x3', '\x2', '\x2', '\x2', '\xE7', '\xEE', '\x5', '\x1E', '\x10', 
		'\x2', '\xE8', '\xE9', '\a', '\x1A', '\x2', '\x2', '\xE9', '\xEE', '\a', 
		' ', '\x2', '\x2', '\xEA', '\xEB', '\x5', '\x12', '\n', '\x2', '\xEB', 
		'\xEC', '\a', ' ', '\x2', '\x2', '\xEC', '\xEE', '\x3', '\x2', '\x2', 
		'\x2', '\xED', '\xE7', '\x3', '\x2', '\x2', '\x2', '\xED', '\xE8', '\x3', 
		'\x2', '\x2', '\x2', '\xED', '\xEA', '\x3', '\x2', '\x2', '\x2', '\xEE', 
		'!', '\x3', '\x2', '\x2', '\x2', '\xEF', '\xF0', '\a', '\x4', '\x2', '\x2', 
		'\xF0', '\xF1', '\x5', '\x44', '#', '\x2', '\xF1', '#', '\x3', '\x2', 
		'\x2', '\x2', '\xF2', '\xF3', '\a', '\x5', '\x2', '\x2', '\xF3', '\xF7', 
		'\a', '\x41', '\x2', '\x2', '\xF4', '\xF5', '\a', '\x6', '\x2', '\x2', 
		'\xF5', '\xF7', '\x5', '\x36', '\x1C', '\x2', '\xF6', '\xF2', '\x3', '\x2', 
		'\x2', '\x2', '\xF6', '\xF4', '\x3', '\x2', '\x2', '\x2', '\xF7', '%', 
		'\x3', '\x2', '\x2', '\x2', '\xF8', '\xFB', '\a', '\a', '\x2', '\x2', 
		'\xF9', '\xFC', '\x5', '>', ' ', '\x2', '\xFA', '\xFC', '\a', '\x39', 
		'\x2', '\x2', '\xFB', '\xF9', '\x3', '\x2', '\x2', '\x2', '\xFB', '\xFA', 
		'\x3', '\x2', '\x2', '\x2', '\xFC', '\'', '\x3', '\x2', '\x2', '\x2', 
		'\xFD', '\xFE', '\a', '\v', '\x2', '\x2', '\xFE', '\xFF', '\a', '\x39', 
		'\x2', '\x2', '\xFF', ')', '\x3', '\x2', '\x2', '\x2', '\x100', '\x101', 
		'\a', '\t', '\x2', '\x2', '\x101', '\x102', '\a', '!', '\x2', '\x2', '\x102', 
		'\x103', '\x5', '\n', '\x6', '\x2', '\x103', '\x104', '\a', '\n', '\x2', 
		'\x2', '\x104', '\x105', '\a', '\x39', '\x2', '\x2', '\x105', '+', '\x3', 
		'\x2', '\x2', '\x2', '\x106', '\x107', '\a', '\"', '\x2', '\x2', '\x107', 
		'\x108', '\x5', '\x36', '\x1C', '\x2', '\x108', '\x109', '\a', '$', '\x2', 
		'\x2', '\x109', '-', '\x3', '\x2', '\x2', '\x2', '\x10A', '\x10B', '\a', 
		'\"', '\x2', '\x2', '\x10B', '\x10C', '\x5', '\x36', '\x1C', '\x2', '\x10C', 
		'\x10D', '\a', '#', '\x2', '\x2', '\x10D', '/', '\x3', '\x2', '\x2', '\x2', 
		'\x10E', '\x10F', '\b', '\x19', '\x1', '\x2', '\x10F', '\x110', '\x5', 
		'\x32', '\x1A', '\x2', '\x110', '\x116', '\x3', '\x2', '\x2', '\x2', '\x111', 
		'\x112', '\f', '\x3', '\x2', '\x2', '\x112', '\x113', '\a', ')', '\x2', 
		'\x2', '\x113', '\x115', '\x5', '\x30', '\x19', '\x4', '\x114', '\x111', 
		'\x3', '\x2', '\x2', '\x2', '\x115', '\x118', '\x3', '\x2', '\x2', '\x2', 
		'\x116', '\x114', '\x3', '\x2', '\x2', '\x2', '\x116', '\x117', '\x3', 
		'\x2', '\x2', '\x2', '\x117', '\x31', '\x3', '\x2', '\x2', '\x2', '\x118', 
		'\x116', '\x3', '\x2', '\x2', '\x2', '\x119', '\x11C', '\x5', ',', '\x17', 
		'\x2', '\x11A', '\x11C', '\x5', '.', '\x18', '\x2', '\x11B', '\x119', 
		'\x3', '\x2', '\x2', '\x2', '\x11B', '\x11A', '\x3', '\x2', '\x2', '\x2', 
		'\x11C', '\x33', '\x3', '\x2', '\x2', '\x2', '\x11D', '\x11E', '\a', '\xE', 
		'\x2', '\x2', '\x11E', '\x120', '\a', '\x39', '\x2', '\x2', '\x11F', '\x121', 
		'\a', '\xF', '\x2', '\x2', '\x120', '\x11F', '\x3', '\x2', '\x2', '\x2', 
		'\x120', '\x121', '\x3', '\x2', '\x2', '\x2', '\x121', '\x122', '\x3', 
		'\x2', '\x2', '\x2', '\x122', '\x123', '\a', '\x10', '\x2', '\x2', '\x123', 
		'\x124', '\x5', '\x36', '\x1C', '\x2', '\x124', '\x35', '\x3', '\x2', 
		'\x2', '\x2', '\x125', '\x126', '\x5', '\x38', '\x1D', '\x2', '\x126', 
		'\x37', '\x3', '\x2', '\x2', '\x2', '\x127', '\x128', '\b', '\x1D', '\x1', 
		'\x2', '\x128', '\x129', '\x5', 'J', '&', '\x2', '\x129', '\x12A', '\x5', 
		'\x38', '\x1D', '\xF', '\x12A', '\x135', '\x3', '\x2', '\x2', '\x2', '\x12B', 
		'\x135', '\x5', ':', '\x1E', '\x2', '\x12C', '\x135', '\x5', '<', '\x1F', 
		'\x2', '\x12D', '\x135', '\x5', '>', ' ', '\x2', '\x12E', '\x135', '\x5', 
		'H', '%', '\x2', '\x12F', '\x135', '\x5', '\x42', '\"', '\x2', '\x130', 
		'\x131', '\a', '\'', '\x2', '\x2', '\x131', '\x132', '\x5', '\x38', '\x1D', 
		'\x2', '\x132', '\x133', '\a', '(', '\x2', '\x2', '\x133', '\x135', '\x3', 
		'\x2', '\x2', '\x2', '\x134', '\x127', '\x3', '\x2', '\x2', '\x2', '\x134', 
		'\x12B', '\x3', '\x2', '\x2', '\x2', '\x134', '\x12C', '\x3', '\x2', '\x2', 
		'\x2', '\x134', '\x12D', '\x3', '\x2', '\x2', '\x2', '\x134', '\x12E', 
		'\x3', '\x2', '\x2', '\x2', '\x134', '\x12F', '\x3', '\x2', '\x2', '\x2', 
		'\x134', '\x130', '\x3', '\x2', '\x2', '\x2', '\x135', '\x150', '\x3', 
		'\x2', '\x2', '\x2', '\x136', '\x137', '\f', '\xE', '\x2', '\x2', '\x137', 
		'\x138', '\x5', 'L', '\'', '\x2', '\x138', '\x139', '\x5', '\x38', '\x1D', 
		'\xF', '\x139', '\x14F', '\x3', '\x2', '\x2', '\x2', '\x13A', '\x13B', 
		'\f', '\r', '\x2', '\x2', '\x13B', '\x13C', '\x5', 'N', '(', '\x2', '\x13C', 
		'\x13D', '\x5', '\x38', '\x1D', '\xE', '\x13D', '\x14F', '\x3', '\x2', 
		'\x2', '\x2', '\x13E', '\x13F', '\f', '\f', '\x2', '\x2', '\x13F', '\x140', 
		'\x5', 'P', ')', '\x2', '\x140', '\x141', '\x5', '\x38', '\x1D', '\r', 
		'\x141', '\x14F', '\x3', '\x2', '\x2', '\x2', '\x142', '\x143', '\f', 
		'\v', '\x2', '\x2', '\x143', '\x144', '\x5', 'R', '*', '\x2', '\x144', 
		'\x145', '\x5', '\x38', '\x1D', '\f', '\x145', '\x14F', '\x3', '\x2', 
		'\x2', '\x2', '\x146', '\x147', '\f', '\n', '\x2', '\x2', '\x147', '\x148', 
		'\x5', 'T', '+', '\x2', '\x148', '\x149', '\x5', '\x38', '\x1D', '\v', 
		'\x149', '\x14F', '\x3', '\x2', '\x2', '\x2', '\x14A', '\x14B', '\f', 
		'\t', '\x2', '\x2', '\x14B', '\x14C', '\x5', 'V', ',', '\x2', '\x14C', 
		'\x14D', '\x5', '\x38', '\x1D', '\n', '\x14D', '\x14F', '\x3', '\x2', 
		'\x2', '\x2', '\x14E', '\x136', '\x3', '\x2', '\x2', '\x2', '\x14E', '\x13A', 
		'\x3', '\x2', '\x2', '\x2', '\x14E', '\x13E', '\x3', '\x2', '\x2', '\x2', 
		'\x14E', '\x142', '\x3', '\x2', '\x2', '\x2', '\x14E', '\x146', '\x3', 
		'\x2', '\x2', '\x2', '\x14E', '\x14A', '\x3', '\x2', '\x2', '\x2', '\x14F', 
		'\x152', '\x3', '\x2', '\x2', '\x2', '\x150', '\x14E', '\x3', '\x2', '\x2', 
		'\x2', '\x150', '\x151', '\x3', '\x2', '\x2', '\x2', '\x151', '\x39', 
		'\x3', '\x2', '\x2', '\x2', '\x152', '\x150', '\x3', '\x2', '\x2', '\x2', 
		'\x153', '\x154', '\a', '\b', '\x2', '\x2', '\x154', '\x155', '\a', '\x39', 
		'\x2', '\x2', '\x155', '\x156', '\a', '\x11', '\x2', '\x2', '\x156', '\x157', 
		'\a', '!', '\x2', '\x2', '\x157', '\x15B', '\x5', '>', ' ', '\x2', '\x158', 
		'\x159', '\a', '\b', '\x2', '\x2', '\x159', '\x15B', '\a', '\x39', '\x2', 
		'\x2', '\x15A', '\x153', '\x3', '\x2', '\x2', '\x2', '\x15A', '\x158', 
		'\x3', '\x2', '\x2', '\x2', '\x15B', ';', '\x3', '\x2', '\x2', '\x2', 
		'\x15C', '\x15D', '\a', '\f', '\x2', '\x2', '\x15D', '\x15E', '\a', '\x39', 
		'\x2', '\x2', '\x15E', '\x15F', '\a', '\r', '\x2', '\x2', '\x15F', '\x160', 
		'\x5', '\x36', '\x1C', '\x2', '\x160', '=', '\x3', '\x2', '\x2', '\x2', 
		'\x161', '\x162', '\a', '%', '\x2', '\x2', '\x162', '\x163', '\x5', '@', 
		'!', '\x2', '\x163', '\x164', '\a', '&', '\x2', '\x2', '\x164', '?', '\x3', 
		'\x2', '\x2', '\x2', '\x165', '\x166', '\b', '!', '\x1', '\x2', '\x166', 
		'\x169', '\x5', '\x36', '\x1C', '\x2', '\x167', '\x169', '\x3', '\x2', 
		'\x2', '\x2', '\x168', '\x165', '\x3', '\x2', '\x2', '\x2', '\x168', '\x167', 
		'\x3', '\x2', '\x2', '\x2', '\x169', '\x16F', '\x3', '\x2', '\x2', '\x2', 
		'\x16A', '\x16B', '\f', '\x4', '\x2', '\x2', '\x16B', '\x16C', '\a', ')', 
		'\x2', '\x2', '\x16C', '\x16E', '\x5', '@', '!', '\x5', '\x16D', '\x16A', 
		'\x3', '\x2', '\x2', '\x2', '\x16E', '\x171', '\x3', '\x2', '\x2', '\x2', 
		'\x16F', '\x16D', '\x3', '\x2', '\x2', '\x2', '\x16F', '\x170', '\x3', 
		'\x2', '\x2', '\x2', '\x170', '\x41', '\x3', '\x2', '\x2', '\x2', '\x171', 
		'\x16F', '\x3', '\x2', '\x2', '\x2', '\x172', '\x175', '\x5', '\x44', 
		'#', '\x2', '\x173', '\x175', '\x5', '\x46', '$', '\x2', '\x174', '\x172', 
		'\x3', '\x2', '\x2', '\x2', '\x174', '\x173', '\x3', '\x2', '\x2', '\x2', 
		'\x175', '\x43', '\x3', '\x2', '\x2', '\x2', '\x176', '\x177', '\t', '\x2', 
		'\x2', '\x2', '\x177', '\x45', '\x3', '\x2', '\x2', '\x2', '\x178', '\x179', 
		'\t', '\x3', '\x2', '\x2', '\x179', 'G', '\x3', '\x2', '\x2', '\x2', '\x17A', 
		'\x17B', '\t', '\x4', '\x2', '\x2', '\x17B', 'I', '\x3', '\x2', '\x2', 
		'\x2', '\x17C', '\x17D', '\t', '\x5', '\x2', '\x2', '\x17D', 'K', '\x3', 
		'\x2', '\x2', '\x2', '\x17E', '\x17F', '\t', '\x6', '\x2', '\x2', '\x17F', 
		'M', '\x3', '\x2', '\x2', '\x2', '\x180', '\x181', '\t', '\a', '\x2', 
		'\x2', '\x181', 'O', '\x3', '\x2', '\x2', '\x2', '\x182', '\x183', '\t', 
		'\b', '\x2', '\x2', '\x183', 'Q', '\x3', '\x2', '\x2', '\x2', '\x184', 
		'\x185', '\t', '\t', '\x2', '\x2', '\x185', 'S', '\x3', '\x2', '\x2', 
		'\x2', '\x186', '\x187', '\a', '.', '\x2', '\x2', '\x187', 'U', '\x3', 
		'\x2', '\x2', '\x2', '\x188', '\x189', '\a', '/', '\x2', '\x2', '\x189', 
		'W', '\x3', '\x2', '\x2', '\x2', '\x1B', 'p', 'w', '\x7F', '\x8A', '\x9A', 
		'\xAA', '\xB0', '\xBF', '\xC7', '\xD0', '\xD9', '\xE5', '\xED', '\xF6', 
		'\xFB', '\x116', '\x11B', '\x120', '\x134', '\x14E', '\x150', '\x15A', 
		'\x168', '\x16F', '\x174',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace Lunalipse.Core.BehaviorScript.ScriptV3.SyntaxParser
