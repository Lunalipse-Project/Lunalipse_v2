//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from LpsScriptParser.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Lunalipse.Core.BehaviorScript.ScriptV3.SyntaxParser {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class LpsScriptParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		PROG_NAME_DECLARE=1, CATALOGUE_CHOOSE=2, PLAY=3, PLAY_NUM=4, SET_EQULAIZER=5, 
		DO_BUILDIN_FUNC=6, PROGRAM_GROUP_START=7, PROGRAM_GROUP_END=8, DO_ACTIONS=9, 
		INDEXING_PREFIX=10, INDEXING_INDEX=11, ASSIGN_PREFIX=12, MAKE_CONSTANT=13, 
		ASSIGN_TO=14, PARAMETER_SPLIT=15, END_PROGRAM=16, AUTHUR_NAME=17, FULLSTOP=18, 
		WITH_ACTION=19, VOLUM=20, REPEAT_TIMES=21, LSQUARE=22, RSQUARE=23, LPAREN=24, 
		RPAREN=25, COMMA=26, ADD=27, MINUS=28, MULT=29, DIV=30, INT=31, REAL=32, 
		ID=33, COMMENT_SINGLE=34, COMMENT_MULTI=35, WS=36, NEW_LINE=37, DONT_CARE1=38, 
		END=39, DONT_CARE2=40, STRING=41, Wspace=42, PROG_START=43, RQUOTE=44;
	public const int
		RULE_prg = 0, RULE_prg_start = 1, RULE_prg_end = 2, RULE_prg_content = 3, 
		RULE_statements = 4, RULE_statement = 5, RULE_cata_choose = 6, RULE_play_actions = 7, 
		RULE_set_eqzr = 8, RULE_do_action = 9, RULE_group_statemnt = 10, RULE_loop_act = 11, 
		RULE_volume_set = 12, RULE_conditions = 13, RULE_condition = 14, RULE_assign = 15, 
		RULE_expr_wrap = 16, RULE_expr = 17, RULE_func_call = 18, RULE_array_indexing = 19, 
		RULE_array = 20, RULE_array_content = 21, RULE_any = 22, RULE_any_id = 23, 
		RULE_any_number = 24, RULE_optr_P1 = 25, RULE_optr_P2 = 26;
	public static readonly string[] ruleNames = {
		"prg", "prg_start", "prg_end", "prg_content", "statements", "statement", 
		"cata_choose", "play_actions", "set_eqzr", "do_action", "group_statemnt", 
		"loop_act", "volume_set", "conditions", "condition", "assign", "expr_wrap", 
		"expr", "func_call", "array_indexing", "array", "array_content", "any", 
		"any_id", "any_number", "optr_P1", "optr_P2"
	};

	private static readonly string[] _LiteralNames = {
		null, "'I would like to tell you my adventure of '", "'For the stuff in '", 
		"'I play music called '", "'I play music numbered '", "'And I would like to set my equalizer using '", 
		null, "'I made up an checklist with the following item'", "'and that is all about checklist of '", 
		"'I start checking the checklist called '", "'I ask '", "' for his stuff at position of '", 
		"'I told '", "'that I have made a Pinkie promise'", "' about '", "' with constraints:'", 
		"'And that is my adventure in today'", "'Your loyal citizen:'", "'.'", 
		"'for '", "' precent of volume'", "' times'", "'['", "']'", "'('", "')'", 
		"','", "'+'", "'-'", "'*'", "'/'", null, null, null, "'P.S.'", "'Here my long waffle start:'", 
		null, null, null, "'And my long waffle end.'", null, null, null, "'Dear Princess Luna:'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "PROG_NAME_DECLARE", "CATALOGUE_CHOOSE", "PLAY", "PLAY_NUM", "SET_EQULAIZER", 
		"DO_BUILDIN_FUNC", "PROGRAM_GROUP_START", "PROGRAM_GROUP_END", "DO_ACTIONS", 
		"INDEXING_PREFIX", "INDEXING_INDEX", "ASSIGN_PREFIX", "MAKE_CONSTANT", 
		"ASSIGN_TO", "PARAMETER_SPLIT", "END_PROGRAM", "AUTHUR_NAME", "FULLSTOP", 
		"WITH_ACTION", "VOLUM", "REPEAT_TIMES", "LSQUARE", "RSQUARE", "LPAREN", 
		"RPAREN", "COMMA", "ADD", "MINUS", "MULT", "DIV", "INT", "REAL", "ID", 
		"COMMENT_SINGLE", "COMMENT_MULTI", "WS", "NEW_LINE", "DONT_CARE1", "END", 
		"DONT_CARE2", "STRING", "Wspace", "PROG_START", "RQUOTE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "LpsScriptParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static LpsScriptParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public LpsScriptParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public LpsScriptParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class PrgContext : ParserRuleContext {
		public Prg_startContext prg_start() {
			return GetRuleContext<Prg_startContext>(0);
		}
		public Prg_contentContext prg_content() {
			return GetRuleContext<Prg_contentContext>(0);
		}
		public Prg_endContext prg_end() {
			return GetRuleContext<Prg_endContext>(0);
		}
		public PrgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrgContext prg() {
		PrgContext _localctx = new PrgContext(Context, State);
		EnterRule(_localctx, 0, RULE_prg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 54; prg_start();
			State = 55; prg_content();
			State = 56; prg_end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prg_startContext : ParserRuleContext {
		public ITerminalNode PROG_START() { return GetToken(LpsScriptParser.PROG_START, 0); }
		public ITerminalNode PROG_NAME_DECLARE() { return GetToken(LpsScriptParser.PROG_NAME_DECLARE, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public Prg_startContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg_start; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg_start(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prg_startContext prg_start() {
		Prg_startContext _localctx = new Prg_startContext(Context, State);
		EnterRule(_localctx, 2, RULE_prg_start);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; Match(PROG_START);
			State = 59; Match(PROG_NAME_DECLARE);
			State = 60; Match(ID);
			State = 61; Match(FULLSTOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prg_endContext : ParserRuleContext {
		public ITerminalNode END_PROGRAM() { return GetToken(LpsScriptParser.END_PROGRAM, 0); }
		public ITerminalNode[] FULLSTOP() { return GetTokens(LpsScriptParser.FULLSTOP); }
		public ITerminalNode FULLSTOP(int i) {
			return GetToken(LpsScriptParser.FULLSTOP, i);
		}
		public ITerminalNode AUTHUR_NAME() { return GetToken(LpsScriptParser.AUTHUR_NAME, 0); }
		public ITerminalNode STRING() { return GetToken(LpsScriptParser.STRING, 0); }
		public Prg_endContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg_end; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg_end(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prg_endContext prg_end() {
		Prg_endContext _localctx = new Prg_endContext(Context, State);
		EnterRule(_localctx, 4, RULE_prg_end);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 63; Match(END_PROGRAM);
			State = 64; Match(FULLSTOP);
			State = 65; Match(AUTHUR_NAME);
			State = 66; Match(STRING);
			State = 67; Match(FULLSTOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prg_contentContext : ParserRuleContext {
		public Group_statemntContext group_statemnt() {
			return GetRuleContext<Group_statemntContext>(0);
		}
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public Prg_contentContext prg_content() {
			return GetRuleContext<Prg_contentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public Prg_contentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prg_content; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrg_content(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prg_contentContext prg_content() {
		Prg_contentContext _localctx = new Prg_contentContext(Context, State);
		EnterRule(_localctx, 6, RULE_prg_content);
		try {
			State = 75;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 69; group_statemnt();
				State = 70; Match(FULLSTOP);
				State = 71; prg_content();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 73; statements(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		return statements(0);
	}

	private StatementsContext statements(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StatementsContext _localctx = new StatementsContext(Context, _parentState);
		StatementsContext _prevctx = _localctx;
		int _startState = 8;
		EnterRecursionRule(_localctx, 8, RULE_statements, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			}
			Context.Stop = TokenStream.LT(-1);
			State = 82;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StatementsContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_statements);
					State = 78;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 79; statement();
					}
					} 
				}
				State = 84;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public Cata_chooseContext cata_choose() {
			return GetRuleContext<Cata_chooseContext>(0);
		}
		public ITerminalNode FULLSTOP() { return GetToken(LpsScriptParser.FULLSTOP, 0); }
		public Play_actionsContext play_actions() {
			return GetRuleContext<Play_actionsContext>(0);
		}
		public ConditionsContext conditions() {
			return GetRuleContext<ConditionsContext>(0);
		}
		public Set_eqzrContext set_eqzr() {
			return GetRuleContext<Set_eqzrContext>(0);
		}
		public Do_actionContext do_action() {
			return GetRuleContext<Do_actionContext>(0);
		}
		public AssignContext assign() {
			return GetRuleContext<AssignContext>(0);
		}
		public Func_callContext func_call() {
			return GetRuleContext<Func_callContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_statement);
		int _la;
		try {
			State = 112;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CATALOGUE_CHOOSE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 85; cata_choose();
				State = 86; Match(FULLSTOP);
				}
				break;
			case PLAY:
			case PLAY_NUM:
				EnterOuterAlt(_localctx, 2);
				{
				State = 88; play_actions();
				State = 90;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH_ACTION) {
					{
					State = 89; conditions(0);
					}
				}

				State = 92; Match(FULLSTOP);
				}
				break;
			case SET_EQULAIZER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 94; set_eqzr();
				State = 95; Match(FULLSTOP);
				}
				break;
			case DO_ACTIONS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 97; do_action();
				State = 99;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH_ACTION) {
					{
					State = 98; conditions(0);
					}
				}

				State = 101; Match(FULLSTOP);
				}
				break;
			case ASSIGN_PREFIX:
				EnterOuterAlt(_localctx, 5);
				{
				State = 103; assign();
				State = 104; Match(FULLSTOP);
				}
				break;
			case DO_BUILDIN_FUNC:
				EnterOuterAlt(_localctx, 6);
				{
				State = 106; func_call();
				State = 108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH_ACTION) {
					{
					State = 107; conditions(0);
					}
				}

				State = 110; Match(FULLSTOP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cata_chooseContext : ParserRuleContext {
		public ITerminalNode CATALOGUE_CHOOSE() { return GetToken(LpsScriptParser.CATALOGUE_CHOOSE, 0); }
		public Any_idContext any_id() {
			return GetRuleContext<Any_idContext>(0);
		}
		public Cata_chooseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cata_choose; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCata_choose(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cata_chooseContext cata_choose() {
		Cata_chooseContext _localctx = new Cata_chooseContext(Context, State);
		EnterRule(_localctx, 12, RULE_cata_choose);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 114; Match(CATALOGUE_CHOOSE);
			State = 115; any_id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Play_actionsContext : ParserRuleContext {
		public ITerminalNode PLAY() { return GetToken(LpsScriptParser.PLAY, 0); }
		public ITerminalNode STRING() { return GetToken(LpsScriptParser.STRING, 0); }
		public ITerminalNode PLAY_NUM() { return GetToken(LpsScriptParser.PLAY_NUM, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public Play_actionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_play_actions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlay_actions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Play_actionsContext play_actions() {
		Play_actionsContext _localctx = new Play_actionsContext(Context, State);
		EnterRule(_localctx, 14, RULE_play_actions);
		try {
			State = 121;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLAY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 117; Match(PLAY);
				State = 118; Match(STRING);
				}
				break;
			case PLAY_NUM:
				EnterOuterAlt(_localctx, 2);
				{
				State = 119; Match(PLAY_NUM);
				State = 120; expr_wrap();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_eqzrContext : ParserRuleContext {
		public ITerminalNode SET_EQULAIZER() { return GetToken(LpsScriptParser.SET_EQULAIZER, 0); }
		public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Set_eqzrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_eqzr; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_eqzr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_eqzrContext set_eqzr() {
		Set_eqzrContext _localctx = new Set_eqzrContext(Context, State);
		EnterRule(_localctx, 16, RULE_set_eqzr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 123; Match(SET_EQULAIZER);
			State = 126;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LSQUARE:
				{
				State = 124; array();
				}
				break;
			case ID:
				{
				State = 125; Match(ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Do_actionContext : ParserRuleContext {
		public ITerminalNode DO_ACTIONS() { return GetToken(LpsScriptParser.DO_ACTIONS, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Do_actionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_do_action; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDo_action(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Do_actionContext do_action() {
		Do_actionContext _localctx = new Do_actionContext(Context, State);
		EnterRule(_localctx, 18, RULE_do_action);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128; Match(DO_ACTIONS);
			State = 129; Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_statemntContext : ParserRuleContext {
		public ITerminalNode PROGRAM_GROUP_START() { return GetToken(LpsScriptParser.PROGRAM_GROUP_START, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode PROGRAM_GROUP_END() { return GetToken(LpsScriptParser.PROGRAM_GROUP_END, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public Group_statemntContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_statemnt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_statemnt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_statemntContext group_statemnt() {
		Group_statemntContext _localctx = new Group_statemntContext(Context, State);
		EnterRule(_localctx, 20, RULE_group_statemnt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 131; Match(PROGRAM_GROUP_START);
			State = 132; statements(0);
			State = 133; Match(PROGRAM_GROUP_END);
			State = 134; Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_actContext : ParserRuleContext {
		public Loop_actContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_act; } }
	 
		public Loop_actContext() { }
		public virtual void CopyFrom(Loop_actContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SuffixLoopContext : Loop_actContext {
		public ITerminalNode WITH_ACTION() { return GetToken(LpsScriptParser.WITH_ACTION, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode REPEAT_TIMES() { return GetToken(LpsScriptParser.REPEAT_TIMES, 0); }
		public SuffixLoopContext(Loop_actContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSuffixLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_actContext loop_act() {
		Loop_actContext _localctx = new Loop_actContext(Context, State);
		EnterRule(_localctx, 22, RULE_loop_act);
		try {
			_localctx = new SuffixLoopContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 136; Match(WITH_ACTION);
			State = 137; expr_wrap();
			State = 138; Match(REPEAT_TIMES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Volume_setContext : ParserRuleContext {
		public Volume_setContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_volume_set; } }
	 
		public Volume_setContext() { }
		public virtual void CopyFrom(Volume_setContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SuffixSetVolContext : Volume_setContext {
		public ITerminalNode WITH_ACTION() { return GetToken(LpsScriptParser.WITH_ACTION, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode VOLUM() { return GetToken(LpsScriptParser.VOLUM, 0); }
		public SuffixSetVolContext(Volume_setContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSuffixSetVol(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Volume_setContext volume_set() {
		Volume_setContext _localctx = new Volume_setContext(Context, State);
		EnterRule(_localctx, 24, RULE_volume_set);
		try {
			_localctx = new SuffixSetVolContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 140; Match(WITH_ACTION);
			State = 141; expr_wrap();
			State = 142; Match(VOLUM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionsContext : ParserRuleContext {
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ConditionsContext[] conditions() {
			return GetRuleContexts<ConditionsContext>();
		}
		public ConditionsContext conditions(int i) {
			return GetRuleContext<ConditionsContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public ConditionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionsContext conditions() {
		return conditions(0);
	}

	private ConditionsContext conditions(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ConditionsContext _localctx = new ConditionsContext(Context, _parentState);
		ConditionsContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_conditions, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 145; condition();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 152;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ConditionsContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_conditions);
					State = 147;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 148; Match(COMMA);
					State = 149; conditions(2);
					}
					} 
				}
				State = 154;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public Loop_actContext loop_act() {
			return GetRuleContext<Loop_actContext>(0);
		}
		public Volume_setContext volume_set() {
			return GetRuleContext<Volume_setContext>(0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(Context, State);
		EnterRule(_localctx, 28, RULE_condition);
		try {
			State = 157;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 155; loop_act();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 156; volume_set();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignContext : ParserRuleContext {
		public ITerminalNode ASSIGN_PREFIX() { return GetToken(LpsScriptParser.ASSIGN_PREFIX, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode ASSIGN_TO() { return GetToken(LpsScriptParser.ASSIGN_TO, 0); }
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public ITerminalNode MAKE_CONSTANT() { return GetToken(LpsScriptParser.MAKE_CONSTANT, 0); }
		public AssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assign; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignContext assign() {
		AssignContext _localctx = new AssignContext(Context, State);
		EnterRule(_localctx, 30, RULE_assign);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 159; Match(ASSIGN_PREFIX);
			State = 160; Match(ID);
			State = 162;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MAKE_CONSTANT) {
				{
				State = 161; Match(MAKE_CONSTANT);
				}
			}

			State = 164; Match(ASSIGN_TO);
			State = 165; expr_wrap();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expr_wrapContext : ParserRuleContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public Expr_wrapContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr_wrap; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_wrap(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expr_wrapContext expr_wrap() {
		Expr_wrapContext _localctx = new Expr_wrapContext(Context, State);
		EnterRule(_localctx, 32, RULE_expr_wrap);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 167; expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
	 
		public ExprContext() { }
		public virtual void CopyFrom(ExprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExprIndContext : ExprContext {
		public Func_callContext func_call() {
			return GetRuleContext<Func_callContext>(0);
		}
		public Array_indexingContext array_indexing() {
			return GetRuleContext<Array_indexingContext>(0);
		}
		public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public AnyContext any() {
			return GetRuleContext<AnyContext>(0);
		}
		public ExprIndContext(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprInd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprParenContext : ExprContext {
		public ITerminalNode LPAREN() { return GetToken(LpsScriptParser.LPAREN, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(LpsScriptParser.RPAREN, 0); }
		public ExprParenContext(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprParen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprUnaryContext : ExprContext {
		public Optr_P2Context optr_P2() {
			return GetRuleContext<Optr_P2Context>(0);
		}
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ExprUnaryContext(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP2Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P2Context optr_P2() {
			return GetRuleContext<Optr_P2Context>(0);
		}
		public ExprP2Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprP1Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Optr_P1Context optr_P1() {
			return GetRuleContext<Optr_P1Context>(0);
		}
		public ExprP1Context(ExprContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprP1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		return expr(0);
	}

	private ExprContext expr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExprContext _localctx = new ExprContext(Context, _parentState);
		ExprContext _prevctx = _localctx;
		int _startState = 34;
		EnterRecursionRule(_localctx, 34, RULE_expr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 181;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
			case MINUS:
				{
				_localctx = new ExprUnaryContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 170; optr_P2();
				State = 171; expr(6);
				}
				break;
			case DO_BUILDIN_FUNC:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 173; func_call();
				}
				break;
			case INDEXING_PREFIX:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 174; array_indexing();
				}
				break;
			case LSQUARE:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 175; array();
				}
				break;
			case INT:
			case REAL:
			case ID:
			case STRING:
				{
				_localctx = new ExprIndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 176; any();
				}
				break;
			case LPAREN:
				{
				_localctx = new ExprParenContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 177; Match(LPAREN);
				State = 178; expr(0);
				State = 179; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 193;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 191;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
					case 1:
						{
						_localctx = new ExprP1Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 183;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 184; optr_P1();
						State = 185; expr(9);
						}
						break;
					case 2:
						{
						_localctx = new ExprP2Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 187;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 188; optr_P2();
						State = 189; expr(8);
						}
						break;
					}
					} 
				}
				State = 195;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Func_callContext : ParserRuleContext {
		public ITerminalNode DO_BUILDIN_FUNC() { return GetToken(LpsScriptParser.DO_BUILDIN_FUNC, 0); }
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode PARAMETER_SPLIT() { return GetToken(LpsScriptParser.PARAMETER_SPLIT, 0); }
		public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public Func_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func_call; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Func_callContext func_call() {
		Func_callContext _localctx = new Func_callContext(Context, State);
		EnterRule(_localctx, 36, RULE_func_call);
		try {
			State = 202;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 196; Match(DO_BUILDIN_FUNC);
				State = 197; Match(ID);
				State = 198; Match(PARAMETER_SPLIT);
				State = 199; array();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 200; Match(DO_BUILDIN_FUNC);
				State = 201; Match(ID);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_indexingContext : ParserRuleContext {
		public ITerminalNode INDEXING_PREFIX() { return GetToken(LpsScriptParser.INDEXING_PREFIX, 0); }
		public ITerminalNode[] ID() { return GetTokens(LpsScriptParser.ID); }
		public ITerminalNode ID(int i) {
			return GetToken(LpsScriptParser.ID, i);
		}
		public ITerminalNode INDEXING_INDEX() { return GetToken(LpsScriptParser.INDEXING_INDEX, 0); }
		public ITerminalNode INT() { return GetToken(LpsScriptParser.INT, 0); }
		public Array_indexingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_indexing; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_indexing(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_indexingContext array_indexing() {
		Array_indexingContext _localctx = new Array_indexingContext(Context, State);
		EnterRule(_localctx, 38, RULE_array_indexing);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204; Match(INDEXING_PREFIX);
			State = 205; Match(ID);
			State = 206; Match(INDEXING_INDEX);
			State = 207;
			_la = TokenStream.LA(1);
			if ( !(_la==INT || _la==ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayContext : ParserRuleContext {
		public ArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array; } }
	 
		public ArrayContext() { }
		public virtual void CopyFrom(ArrayContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ArrayDeclrContext : ArrayContext {
		public ITerminalNode LSQUARE() { return GetToken(LpsScriptParser.LSQUARE, 0); }
		public Array_contentContext array_content() {
			return GetRuleContext<Array_contentContext>(0);
		}
		public ITerminalNode RSQUARE() { return GetToken(LpsScriptParser.RSQUARE, 0); }
		public ArrayDeclrContext(ArrayContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayDeclr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayContext array() {
		ArrayContext _localctx = new ArrayContext(Context, State);
		EnterRule(_localctx, 40, RULE_array);
		try {
			_localctx = new ArrayDeclrContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 209; Match(LSQUARE);
			State = 210; array_content(0);
			State = 211; Match(RSQUARE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_contentContext : ParserRuleContext {
		public Expr_wrapContext expr_wrap() {
			return GetRuleContext<Expr_wrapContext>(0);
		}
		public Array_contentContext[] array_content() {
			return GetRuleContexts<Array_contentContext>();
		}
		public Array_contentContext array_content(int i) {
			return GetRuleContext<Array_contentContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(LpsScriptParser.COMMA, 0); }
		public Array_contentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_content; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_content(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_contentContext array_content() {
		return array_content(0);
	}

	private Array_contentContext array_content(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Array_contentContext _localctx = new Array_contentContext(Context, _parentState);
		Array_contentContext _prevctx = _localctx;
		int _startState = 42;
		EnterRecursionRule(_localctx, 42, RULE_array_content, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 216;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 214; expr_wrap();
				}
				break;
			case 2:
				{
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 223;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Array_contentContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_array_content);
					State = 218;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 219; Match(COMMA);
					State = 220; array_content(3);
					}
					} 
				}
				State = 225;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AnyContext : ParserRuleContext {
		public Any_idContext any_id() {
			return GetRuleContext<Any_idContext>(0);
		}
		public Any_numberContext any_number() {
			return GetRuleContext<Any_numberContext>(0);
		}
		public AnyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_any; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAny(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnyContext any() {
		AnyContext _localctx = new AnyContext(Context, State);
		EnterRule(_localctx, 44, RULE_any);
		try {
			State = 228;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ID:
			case STRING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 226; any_id();
				}
				break;
			case INT:
			case REAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 227; any_number();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Any_idContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(LpsScriptParser.ID, 0); }
		public ITerminalNode STRING() { return GetToken(LpsScriptParser.STRING, 0); }
		public Any_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_any_id; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAny_id(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Any_idContext any_id() {
		Any_idContext _localctx = new Any_idContext(Context, State);
		EnterRule(_localctx, 46, RULE_any_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 230;
			_la = TokenStream.LA(1);
			if ( !(_la==ID || _la==STRING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Any_numberContext : ParserRuleContext {
		public ITerminalNode REAL() { return GetToken(LpsScriptParser.REAL, 0); }
		public ITerminalNode INT() { return GetToken(LpsScriptParser.INT, 0); }
		public Any_numberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_any_number; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAny_number(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Any_numberContext any_number() {
		Any_numberContext _localctx = new Any_numberContext(Context, State);
		EnterRule(_localctx, 48, RULE_any_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 232;
			_la = TokenStream.LA(1);
			if ( !(_la==INT || _la==REAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P1Context : ParserRuleContext {
		public ITerminalNode MULT() { return GetToken(LpsScriptParser.MULT, 0); }
		public ITerminalNode DIV() { return GetToken(LpsScriptParser.DIV, 0); }
		public Optr_P1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P1; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P1Context optr_P1() {
		Optr_P1Context _localctx = new Optr_P1Context(Context, State);
		EnterRule(_localctx, 50, RULE_optr_P1);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 234;
			_la = TokenStream.LA(1);
			if ( !(_la==MULT || _la==DIV) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Optr_P2Context : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(LpsScriptParser.ADD, 0); }
		public ITerminalNode MINUS() { return GetToken(LpsScriptParser.MINUS, 0); }
		public Optr_P2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optr_P2; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ILpsScriptParserVisitor<TResult> typedVisitor = visitor as ILpsScriptParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptr_P2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Optr_P2Context optr_P2() {
		Optr_P2Context _localctx = new Optr_P2Context(Context, State);
		EnterRule(_localctx, 52, RULE_optr_P2);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 236;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==MINUS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 4: return statements_sempred((StatementsContext)_localctx, predIndex);
		case 13: return conditions_sempred((ConditionsContext)_localctx, predIndex);
		case 17: return expr_sempred((ExprContext)_localctx, predIndex);
		case 21: return array_content_sempred((Array_contentContext)_localctx, predIndex);
		}
		return true;
	}
	private bool statements_sempred(StatementsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		}
		return true;
	}
	private bool conditions_sempred(ConditionsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool expr_sempred(ExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 8);
		case 3: return Precpred(Context, 7);
		}
		return true;
	}
	private bool array_content_sempred(Array_contentContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 2);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '.', '\xF1', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x5', '\x3', 
		'\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x5', 
		'\x5', 'N', '\n', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\a', 
		'\x6', 'S', '\n', '\x6', '\f', '\x6', '\xE', '\x6', 'V', '\v', '\x6', 
		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x5', 
		'\a', ']', '\n', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', 
		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\x5', '\a', '\x66', '\n', '\a', 
		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', 
		'\a', '\x3', '\a', '\x5', '\a', 'o', '\n', '\a', '\x3', '\a', '\x3', '\a', 
		'\x5', '\a', 's', '\n', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', '|', '\n', '\t', 
		'\x3', '\n', '\x3', '\n', '\x3', '\n', '\x5', '\n', '\x81', '\n', '\n', 
		'\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x3', '\f', '\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\r', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\a', '\xF', '\x99', '\n', '\xF', '\f', '\xF', '\xE', '\xF', '\x9C', 
		'\v', '\xF', '\x3', '\x10', '\x3', '\x10', '\x5', '\x10', '\xA0', '\n', 
		'\x10', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x5', '\x11', '\xA5', 
		'\n', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x12', 
		'\x3', '\x12', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', 
		'\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', 
		'\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x5', '\x13', '\xB8', '\n', 
		'\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', 
		'\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\a', '\x13', '\xC2', 
		'\n', '\x13', '\f', '\x13', '\xE', '\x13', '\xC5', '\v', '\x13', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x5', '\x14', '\xCD', '\n', '\x14', '\x3', '\x15', '\x3', '\x15', 
		'\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x16', '\x3', '\x16', 
		'\x3', '\x16', '\x3', '\x16', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', 
		'\x5', '\x17', '\xDB', '\n', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', 
		'\x17', '\a', '\x17', '\xE0', '\n', '\x17', '\f', '\x17', '\xE', '\x17', 
		'\xE3', '\v', '\x17', '\x3', '\x18', '\x3', '\x18', '\x5', '\x18', '\xE7', 
		'\n', '\x18', '\x3', '\x19', '\x3', '\x19', '\x3', '\x1A', '\x3', '\x1A', 
		'\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', 
		'\x2', '\x6', '\n', '\x1C', '$', ',', '\x1D', '\x2', '\x4', '\x6', '\b', 
		'\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', 
		'\x1E', ' ', '\"', '$', '&', '(', '*', ',', '.', '\x30', '\x32', '\x34', 
		'\x36', '\x2', '\a', '\x4', '\x2', '!', '!', '#', '#', '\x4', '\x2', '#', 
		'#', '+', '+', '\x3', '\x2', '!', '\"', '\x3', '\x2', '\x1F', ' ', '\x3', 
		'\x2', '\x1D', '\x1E', '\x2', '\xF0', '\x2', '\x38', '\x3', '\x2', '\x2', 
		'\x2', '\x4', '<', '\x3', '\x2', '\x2', '\x2', '\x6', '\x41', '\x3', '\x2', 
		'\x2', '\x2', '\b', 'M', '\x3', '\x2', '\x2', '\x2', '\n', 'O', '\x3', 
		'\x2', '\x2', '\x2', '\f', 'r', '\x3', '\x2', '\x2', '\x2', '\xE', 't', 
		'\x3', '\x2', '\x2', '\x2', '\x10', '{', '\x3', '\x2', '\x2', '\x2', '\x12', 
		'}', '\x3', '\x2', '\x2', '\x2', '\x14', '\x82', '\x3', '\x2', '\x2', 
		'\x2', '\x16', '\x85', '\x3', '\x2', '\x2', '\x2', '\x18', '\x8A', '\x3', 
		'\x2', '\x2', '\x2', '\x1A', '\x8E', '\x3', '\x2', '\x2', '\x2', '\x1C', 
		'\x92', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x9F', '\x3', '\x2', '\x2', 
		'\x2', ' ', '\xA1', '\x3', '\x2', '\x2', '\x2', '\"', '\xA9', '\x3', '\x2', 
		'\x2', '\x2', '$', '\xB7', '\x3', '\x2', '\x2', '\x2', '&', '\xCC', '\x3', 
		'\x2', '\x2', '\x2', '(', '\xCE', '\x3', '\x2', '\x2', '\x2', '*', '\xD3', 
		'\x3', '\x2', '\x2', '\x2', ',', '\xDA', '\x3', '\x2', '\x2', '\x2', '.', 
		'\xE6', '\x3', '\x2', '\x2', '\x2', '\x30', '\xE8', '\x3', '\x2', '\x2', 
		'\x2', '\x32', '\xEA', '\x3', '\x2', '\x2', '\x2', '\x34', '\xEC', '\x3', 
		'\x2', '\x2', '\x2', '\x36', '\xEE', '\x3', '\x2', '\x2', '\x2', '\x38', 
		'\x39', '\x5', '\x4', '\x3', '\x2', '\x39', ':', '\x5', '\b', '\x5', '\x2', 
		':', ';', '\x5', '\x6', '\x4', '\x2', ';', '\x3', '\x3', '\x2', '\x2', 
		'\x2', '<', '=', '\a', '-', '\x2', '\x2', '=', '>', '\a', '\x3', '\x2', 
		'\x2', '>', '?', '\a', '#', '\x2', '\x2', '?', '@', '\a', '\x14', '\x2', 
		'\x2', '@', '\x5', '\x3', '\x2', '\x2', '\x2', '\x41', '\x42', '\a', '\x12', 
		'\x2', '\x2', '\x42', '\x43', '\a', '\x14', '\x2', '\x2', '\x43', '\x44', 
		'\a', '\x13', '\x2', '\x2', '\x44', '\x45', '\a', '+', '\x2', '\x2', '\x45', 
		'\x46', '\a', '\x14', '\x2', '\x2', '\x46', '\a', '\x3', '\x2', '\x2', 
		'\x2', 'G', 'H', '\x5', '\x16', '\f', '\x2', 'H', 'I', '\a', '\x14', '\x2', 
		'\x2', 'I', 'J', '\x5', '\b', '\x5', '\x2', 'J', 'N', '\x3', '\x2', '\x2', 
		'\x2', 'K', 'N', '\x5', '\n', '\x6', '\x2', 'L', 'N', '\x3', '\x2', '\x2', 
		'\x2', 'M', 'G', '\x3', '\x2', '\x2', '\x2', 'M', 'K', '\x3', '\x2', '\x2', 
		'\x2', 'M', 'L', '\x3', '\x2', '\x2', '\x2', 'N', '\t', '\x3', '\x2', 
		'\x2', '\x2', 'O', 'T', '\b', '\x6', '\x1', '\x2', 'P', 'Q', '\f', '\x4', 
		'\x2', '\x2', 'Q', 'S', '\x5', '\f', '\a', '\x2', 'R', 'P', '\x3', '\x2', 
		'\x2', '\x2', 'S', 'V', '\x3', '\x2', '\x2', '\x2', 'T', 'R', '\x3', '\x2', 
		'\x2', '\x2', 'T', 'U', '\x3', '\x2', '\x2', '\x2', 'U', '\v', '\x3', 
		'\x2', '\x2', '\x2', 'V', 'T', '\x3', '\x2', '\x2', '\x2', 'W', 'X', '\x5', 
		'\xE', '\b', '\x2', 'X', 'Y', '\a', '\x14', '\x2', '\x2', 'Y', 's', '\x3', 
		'\x2', '\x2', '\x2', 'Z', '\\', '\x5', '\x10', '\t', '\x2', '[', ']', 
		'\x5', '\x1C', '\xF', '\x2', '\\', '[', '\x3', '\x2', '\x2', '\x2', '\\', 
		']', '\x3', '\x2', '\x2', '\x2', ']', '^', '\x3', '\x2', '\x2', '\x2', 
		'^', '_', '\a', '\x14', '\x2', '\x2', '_', 's', '\x3', '\x2', '\x2', '\x2', 
		'`', '\x61', '\x5', '\x12', '\n', '\x2', '\x61', '\x62', '\a', '\x14', 
		'\x2', '\x2', '\x62', 's', '\x3', '\x2', '\x2', '\x2', '\x63', '\x65', 
		'\x5', '\x14', '\v', '\x2', '\x64', '\x66', '\x5', '\x1C', '\xF', '\x2', 
		'\x65', '\x64', '\x3', '\x2', '\x2', '\x2', '\x65', '\x66', '\x3', '\x2', 
		'\x2', '\x2', '\x66', 'g', '\x3', '\x2', '\x2', '\x2', 'g', 'h', '\a', 
		'\x14', '\x2', '\x2', 'h', 's', '\x3', '\x2', '\x2', '\x2', 'i', 'j', 
		'\x5', ' ', '\x11', '\x2', 'j', 'k', '\a', '\x14', '\x2', '\x2', 'k', 
		's', '\x3', '\x2', '\x2', '\x2', 'l', 'n', '\x5', '&', '\x14', '\x2', 
		'm', 'o', '\x5', '\x1C', '\xF', '\x2', 'n', 'm', '\x3', '\x2', '\x2', 
		'\x2', 'n', 'o', '\x3', '\x2', '\x2', '\x2', 'o', 'p', '\x3', '\x2', '\x2', 
		'\x2', 'p', 'q', '\a', '\x14', '\x2', '\x2', 'q', 's', '\x3', '\x2', '\x2', 
		'\x2', 'r', 'W', '\x3', '\x2', '\x2', '\x2', 'r', 'Z', '\x3', '\x2', '\x2', 
		'\x2', 'r', '`', '\x3', '\x2', '\x2', '\x2', 'r', '\x63', '\x3', '\x2', 
		'\x2', '\x2', 'r', 'i', '\x3', '\x2', '\x2', '\x2', 'r', 'l', '\x3', '\x2', 
		'\x2', '\x2', 's', '\r', '\x3', '\x2', '\x2', '\x2', 't', 'u', '\a', '\x4', 
		'\x2', '\x2', 'u', 'v', '\x5', '\x30', '\x19', '\x2', 'v', '\xF', '\x3', 
		'\x2', '\x2', '\x2', 'w', 'x', '\a', '\x5', '\x2', '\x2', 'x', '|', '\a', 
		'+', '\x2', '\x2', 'y', 'z', '\a', '\x6', '\x2', '\x2', 'z', '|', '\x5', 
		'\"', '\x12', '\x2', '{', 'w', '\x3', '\x2', '\x2', '\x2', '{', 'y', '\x3', 
		'\x2', '\x2', '\x2', '|', '\x11', '\x3', '\x2', '\x2', '\x2', '}', '\x80', 
		'\a', '\a', '\x2', '\x2', '~', '\x81', '\x5', '*', '\x16', '\x2', '\x7F', 
		'\x81', '\a', '#', '\x2', '\x2', '\x80', '~', '\x3', '\x2', '\x2', '\x2', 
		'\x80', '\x7F', '\x3', '\x2', '\x2', '\x2', '\x81', '\x13', '\x3', '\x2', 
		'\x2', '\x2', '\x82', '\x83', '\a', '\v', '\x2', '\x2', '\x83', '\x84', 
		'\a', '#', '\x2', '\x2', '\x84', '\x15', '\x3', '\x2', '\x2', '\x2', '\x85', 
		'\x86', '\a', '\t', '\x2', '\x2', '\x86', '\x87', '\x5', '\n', '\x6', 
		'\x2', '\x87', '\x88', '\a', '\n', '\x2', '\x2', '\x88', '\x89', '\a', 
		'#', '\x2', '\x2', '\x89', '\x17', '\x3', '\x2', '\x2', '\x2', '\x8A', 
		'\x8B', '\a', '\x15', '\x2', '\x2', '\x8B', '\x8C', '\x5', '\"', '\x12', 
		'\x2', '\x8C', '\x8D', '\a', '\x17', '\x2', '\x2', '\x8D', '\x19', '\x3', 
		'\x2', '\x2', '\x2', '\x8E', '\x8F', '\a', '\x15', '\x2', '\x2', '\x8F', 
		'\x90', '\x5', '\"', '\x12', '\x2', '\x90', '\x91', '\a', '\x16', '\x2', 
		'\x2', '\x91', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x92', '\x93', '\b', 
		'\xF', '\x1', '\x2', '\x93', '\x94', '\x5', '\x1E', '\x10', '\x2', '\x94', 
		'\x9A', '\x3', '\x2', '\x2', '\x2', '\x95', '\x96', '\f', '\x3', '\x2', 
		'\x2', '\x96', '\x97', '\a', '\x1C', '\x2', '\x2', '\x97', '\x99', '\x5', 
		'\x1C', '\xF', '\x4', '\x98', '\x95', '\x3', '\x2', '\x2', '\x2', '\x99', 
		'\x9C', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x98', '\x3', '\x2', '\x2', 
		'\x2', '\x9A', '\x9B', '\x3', '\x2', '\x2', '\x2', '\x9B', '\x1D', '\x3', 
		'\x2', '\x2', '\x2', '\x9C', '\x9A', '\x3', '\x2', '\x2', '\x2', '\x9D', 
		'\xA0', '\x5', '\x18', '\r', '\x2', '\x9E', '\xA0', '\x5', '\x1A', '\xE', 
		'\x2', '\x9F', '\x9D', '\x3', '\x2', '\x2', '\x2', '\x9F', '\x9E', '\x3', 
		'\x2', '\x2', '\x2', '\xA0', '\x1F', '\x3', '\x2', '\x2', '\x2', '\xA1', 
		'\xA2', '\a', '\xE', '\x2', '\x2', '\xA2', '\xA4', '\a', '#', '\x2', '\x2', 
		'\xA3', '\xA5', '\a', '\xF', '\x2', '\x2', '\xA4', '\xA3', '\x3', '\x2', 
		'\x2', '\x2', '\xA4', '\xA5', '\x3', '\x2', '\x2', '\x2', '\xA5', '\xA6', 
		'\x3', '\x2', '\x2', '\x2', '\xA6', '\xA7', '\a', '\x10', '\x2', '\x2', 
		'\xA7', '\xA8', '\x5', '\"', '\x12', '\x2', '\xA8', '!', '\x3', '\x2', 
		'\x2', '\x2', '\xA9', '\xAA', '\x5', '$', '\x13', '\x2', '\xAA', '#', 
		'\x3', '\x2', '\x2', '\x2', '\xAB', '\xAC', '\b', '\x13', '\x1', '\x2', 
		'\xAC', '\xAD', '\x5', '\x36', '\x1C', '\x2', '\xAD', '\xAE', '\x5', '$', 
		'\x13', '\b', '\xAE', '\xB8', '\x3', '\x2', '\x2', '\x2', '\xAF', '\xB8', 
		'\x5', '&', '\x14', '\x2', '\xB0', '\xB8', '\x5', '(', '\x15', '\x2', 
		'\xB1', '\xB8', '\x5', '*', '\x16', '\x2', '\xB2', '\xB8', '\x5', '.', 
		'\x18', '\x2', '\xB3', '\xB4', '\a', '\x1A', '\x2', '\x2', '\xB4', '\xB5', 
		'\x5', '$', '\x13', '\x2', '\xB5', '\xB6', '\a', '\x1B', '\x2', '\x2', 
		'\xB6', '\xB8', '\x3', '\x2', '\x2', '\x2', '\xB7', '\xAB', '\x3', '\x2', 
		'\x2', '\x2', '\xB7', '\xAF', '\x3', '\x2', '\x2', '\x2', '\xB7', '\xB0', 
		'\x3', '\x2', '\x2', '\x2', '\xB7', '\xB1', '\x3', '\x2', '\x2', '\x2', 
		'\xB7', '\xB2', '\x3', '\x2', '\x2', '\x2', '\xB7', '\xB3', '\x3', '\x2', 
		'\x2', '\x2', '\xB8', '\xC3', '\x3', '\x2', '\x2', '\x2', '\xB9', '\xBA', 
		'\f', '\n', '\x2', '\x2', '\xBA', '\xBB', '\x5', '\x34', '\x1B', '\x2', 
		'\xBB', '\xBC', '\x5', '$', '\x13', '\v', '\xBC', '\xC2', '\x3', '\x2', 
		'\x2', '\x2', '\xBD', '\xBE', '\f', '\t', '\x2', '\x2', '\xBE', '\xBF', 
		'\x5', '\x36', '\x1C', '\x2', '\xBF', '\xC0', '\x5', '$', '\x13', '\n', 
		'\xC0', '\xC2', '\x3', '\x2', '\x2', '\x2', '\xC1', '\xB9', '\x3', '\x2', 
		'\x2', '\x2', '\xC1', '\xBD', '\x3', '\x2', '\x2', '\x2', '\xC2', '\xC5', 
		'\x3', '\x2', '\x2', '\x2', '\xC3', '\xC1', '\x3', '\x2', '\x2', '\x2', 
		'\xC3', '\xC4', '\x3', '\x2', '\x2', '\x2', '\xC4', '%', '\x3', '\x2', 
		'\x2', '\x2', '\xC5', '\xC3', '\x3', '\x2', '\x2', '\x2', '\xC6', '\xC7', 
		'\a', '\b', '\x2', '\x2', '\xC7', '\xC8', '\a', '#', '\x2', '\x2', '\xC8', 
		'\xC9', '\a', '\x11', '\x2', '\x2', '\xC9', '\xCD', '\x5', '*', '\x16', 
		'\x2', '\xCA', '\xCB', '\a', '\b', '\x2', '\x2', '\xCB', '\xCD', '\a', 
		'#', '\x2', '\x2', '\xCC', '\xC6', '\x3', '\x2', '\x2', '\x2', '\xCC', 
		'\xCA', '\x3', '\x2', '\x2', '\x2', '\xCD', '\'', '\x3', '\x2', '\x2', 
		'\x2', '\xCE', '\xCF', '\a', '\f', '\x2', '\x2', '\xCF', '\xD0', '\a', 
		'#', '\x2', '\x2', '\xD0', '\xD1', '\a', '\r', '\x2', '\x2', '\xD1', '\xD2', 
		'\t', '\x2', '\x2', '\x2', '\xD2', ')', '\x3', '\x2', '\x2', '\x2', '\xD3', 
		'\xD4', '\a', '\x18', '\x2', '\x2', '\xD4', '\xD5', '\x5', ',', '\x17', 
		'\x2', '\xD5', '\xD6', '\a', '\x19', '\x2', '\x2', '\xD6', '+', '\x3', 
		'\x2', '\x2', '\x2', '\xD7', '\xD8', '\b', '\x17', '\x1', '\x2', '\xD8', 
		'\xDB', '\x5', '\"', '\x12', '\x2', '\xD9', '\xDB', '\x3', '\x2', '\x2', 
		'\x2', '\xDA', '\xD7', '\x3', '\x2', '\x2', '\x2', '\xDA', '\xD9', '\x3', 
		'\x2', '\x2', '\x2', '\xDB', '\xE1', '\x3', '\x2', '\x2', '\x2', '\xDC', 
		'\xDD', '\f', '\x4', '\x2', '\x2', '\xDD', '\xDE', '\a', '\x1C', '\x2', 
		'\x2', '\xDE', '\xE0', '\x5', ',', '\x17', '\x5', '\xDF', '\xDC', '\x3', 
		'\x2', '\x2', '\x2', '\xE0', '\xE3', '\x3', '\x2', '\x2', '\x2', '\xE1', 
		'\xDF', '\x3', '\x2', '\x2', '\x2', '\xE1', '\xE2', '\x3', '\x2', '\x2', 
		'\x2', '\xE2', '-', '\x3', '\x2', '\x2', '\x2', '\xE3', '\xE1', '\x3', 
		'\x2', '\x2', '\x2', '\xE4', '\xE7', '\x5', '\x30', '\x19', '\x2', '\xE5', 
		'\xE7', '\x5', '\x32', '\x1A', '\x2', '\xE6', '\xE4', '\x3', '\x2', '\x2', 
		'\x2', '\xE6', '\xE5', '\x3', '\x2', '\x2', '\x2', '\xE7', '/', '\x3', 
		'\x2', '\x2', '\x2', '\xE8', '\xE9', '\t', '\x3', '\x2', '\x2', '\xE9', 
		'\x31', '\x3', '\x2', '\x2', '\x2', '\xEA', '\xEB', '\t', '\x4', '\x2', 
		'\x2', '\xEB', '\x33', '\x3', '\x2', '\x2', '\x2', '\xEC', '\xED', '\t', 
		'\x5', '\x2', '\x2', '\xED', '\x35', '\x3', '\x2', '\x2', '\x2', '\xEE', 
		'\xEF', '\t', '\x6', '\x2', '\x2', '\xEF', '\x37', '\x3', '\x2', '\x2', 
		'\x2', '\x14', 'M', 'T', '\\', '\x65', 'n', 'r', '{', '\x80', '\x9A', 
		'\x9F', '\xA4', '\xB7', '\xC1', '\xC3', '\xCC', '\xDA', '\xE1', '\xE6',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace Lunalipse.Core.BehaviorScript.ScriptV3.SyntaxParser
